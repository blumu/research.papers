\documentclass{article}
\usepackage{a4wide}
\usepackage{amsmath, amsthm, amssymb}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{prop}[thm]{Proposition}



\newcommand{\encode}[1]{\ulcorner #1 \urcorner}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}

\newcommand\eop{{\sf eop}}
\newcommand{\betared}{\rightarrow_\beta}

%pcf
\newcommand\ialgol{{\textsl{IA}}}
\newcommand\pcf{\textsl{PCF}}
\newcommand\pcfcond{\texttt{cond}}
\newcommand\pcfsucc{\texttt{succ}}
\newcommand\pcfpred{\texttt{pred}}

\newcommand\iaskip{\texttt{skip}}



\author{William Blum}
\title{Two results about the Safe Lambda Calculus}


\begin{document}
\maketitle

\begin{abstract}
The \emph{safety condition} was introduced in \cite{KNU02} as a syntactic restriction for higher-order grammars that constrains occurrences of variables in the grammar equations according to their order. When transposed to the $\lambda$-calculus, the safety condition gives rise to the \emph{safe $\lambda$-calculus}, an $\alpha$-conversion free sub-language of the $\lambda$-calculus with a succinct game semantics (i.e.\ pointers emanating from P-moves can be recovered uniquely from the underlying sequence of moves and from O-moves' pointers) \cite{blumtransfer}.

This note presents two new results: the functions representable in the safe $\lambda$-calculus are exactly the polynomials; observational equivalence for the safe finitary fragment of IA is undecidable.
\end{abstract}

\section{Function Representable in the Safe $\lambda$-Calculus}

In \cite{citeulike:622637}, Schwichtenberg showed that
numerical functions representable in the Simply Typed Lambda Calculus are exactly the multivariate polynomials \emph{extended with the conditional function}:
\begin{theorem}
The functions representable by $\lambda$-expressions of type $I\rightarrow I \rightarrow \ldots \rightarrow I$ where $I = (o\rightarrow o)\rightarrow o\rightarrow o$ are exactly the functions generated by the constants $0$ and $1$ using the operations addition, multiplication and conditional.
\end{theorem}

We prove that if we limit ourselves to Safe terms, the representable functions are exactly the multivariate polynomials:
\begin{theorem}
\label{thm:polychar}
The functions representable by Safe $\lambda$-expressions of type $I\rightarrow I \rightarrow \ldots \rightarrow I$ where $I = (o\rightarrow o)\rightarrow o\rightarrow o$ are exactly the functions generated by the constants $0$ and $1$ using the operations addition and multiplication.
\end{theorem}
\begin{proof}
Numbers constants are encoded using Church Numerals: $\encode{n} = \lambda s z. s^n z$.
Addition: for $n,m \in \nat$, $\encode{n+m} = \lambda \alpha^{(o,o)} x^o . (\encode{n} \alpha) (\encode{m} \alpha x)$. Multiplication: $\encode{n . m} = \lambda \alpha^{(o,o)} . \encode{n} (\encode{m} \alpha)$.
All these terms are safe and clearly any multivariate polynomial $P(n_1, \ldots, n_k)$ can be computed by composing the addition and multiplication terms as appropriate.

We now prove the converse. We consider safe lambda terms of type $I\rightarrow I  \rightarrow I$ which corresponds to polynomials with 2 variables. The generalisation to terms of type $I^n \rightarrow I$ for $n>2$ is immediate (they correspond to polynomials with $n$ variables).

Consider a Safe $\lambda$-term $U:I\rightarrow I\rightarrow I$. Without lose of generality we can assume that $U = \lambda x y \alpha z. u$ where $u$ is a safe term of ground type in $\beta$-normal form with $fv(u) \subseteq \{ x, y : I, z :o, \alpha : o\rightarrow o \}$.

\emph{Notation:} Let $T$ be a set of terms of type $\tau \rightarrow \tau$ and $T'$ be a set of terms of type $\tau$ then $T \cdot T'$ denotes the set of terms $\{ s s' : \tau \ | \ s \in T \wedge s' \in T' \}$. We also define
$T^k \cdot T'$ recursively as follows:  $T^0 \cdot T' = T'$ and
for $k\geq 0$, $T^{k+1} \cdot T' = T \cdot (T^k \cdot T')$ (i.e. $T^k \cdot T'$ denotes $\{ s_1( \ldots (s_k s'))  \ | \ s_1, \ldots, s_k \in T \wedge s' \in T' \}$). We define $T^+\cdot T' = \Union_{k > 0} T^k \cdot T'$ and
$T^*\cdot T' = (T^+\cdot T') \union T'$.

Let us write $\mathcal{N}^\tau$ for the set of $\beta$-normal terms of type $\tau$ where $\tau$ ranges in $\{ o, o\rightarrow o, I  \}$ and with free variables in $\{ x,y:I, z:o, \alpha:o\rightarrow o\}$. We write $\mathcal{A}^\tau$ for the subset of $\mathcal{N}^\tau$ consisting of applicative terms only (i.e. not abstractions).

Let $B$ be the set of terms of type $o\rightarrow o$ defined by $B = \{ \alpha \} \union \{ \lambda a.b \ | \ b \in \{a,z\}, a \neq z \}$.
It is easy to see that the following equations hold:
\begin{eqnarray*}
\mathcal{A}^I &=& \{ x,y \} \\
\mathcal{N}^{(o,o)} &=& B \union \mathcal{A}^I \cdot
\mathcal{N}^{(o,o)} = (\mathcal{A}^I)^* \cdot B \\
\mathcal{A}^{(o,o)} &=& \{ \alpha \} \union (\mathcal{A}^I)^+ \cdot B \\
\mathcal{N}^o &=& \{ z \} \union \mathcal{A}^{(o,o)} \cdot \mathcal{N}^o = (\mathcal{A}^{(o,o)})^* \cdot \{ z \} \\
\mathcal{A}^o &=& \mathcal{N}^{o}
\end{eqnarray*}

Consequently, $$\mathcal{A}^o = \left( \{\alpha \} \union \{x,y\}^+ \cdot \left( \{\alpha \} \union \{\lambda a.b \ | \ b \in \{a,z\}, a \neq z \} \right) \right)^* \cdot \{ z \}$$

We have $u \in \mathcal{A}^o$. Moreover since $u$ is a safe term,
terms of the form $\lambda a . z$ with $a \neq z$ cannot occur at an
operand position in $u$. Therefore:
\begin{equation}
u \in \left( \{\alpha\} \union \{x,y\}^+ \cdot \{\alpha,
\underline{i} \} \right)^* \cdot \{ z \} \label{eqn:u}
\end{equation}
where $\underline{i}$ is the identity term of type $o\rightarrow o$.

For two sets of terms $T$ and $T'$, we introduce the notation $T =_\beta T'$ meaning that for all $t \in T$, there is a $t' \in T'$ such that $t =_\beta t'$ and reciprocally.

We observe that for all $m \in \nat$, we have $\encode{m} \underline{i} =_\beta \underline{i}$ and for $l\geq 1$, for all $k_1, \ldots k_l \in \nat$,
$\encode{k_1}\ldots \encode{k_l} \alpha =_\beta
\encode{k_1\times \ldots \times k_l} \alpha$. Hence
\begin{align}
\{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} &=_\beta
\{ \underline{i} \} \union
\{ \encode{m^i n^j} \alpha \ |\ i+j \geq 1 \} \nonumber \\
&= \{ \encode{m^i n^j} \alpha \ |\ i,j \geq 0 \} & ( \mbox{since } \encode{0} \alpha = \underline{i}) \label{eqn:intermediate}
\end{align}
and we have:
\begin{align*}
u[\encode{m} \encode{n}/x,y] &\in \left( \{ \alpha \} \union \{\encode{m},\encode{n}\}^+ \cdot \{\alpha, \underline{i} \} \right)^* \cdot \{ z \}  & \mbox{(by Eq.\ \ref{eqn:u})} \\
&=_\beta \left( \{\alpha \} \union \{ \encode{m^i n^j}
\alpha \ | \ i,j \geq 0 \} \right)^* \cdot \{ z \} & \mbox{(by Eq.\ \ref{eqn:intermediate})}
\end{align*}

Furthemore, the following equalities hold for all $m,n,r\in \nat,i,j\geq 0$:
\begin{eqnarray*}
\encode{m^i n^j} \alpha (\alpha^r z) &=_\beta&
\alpha^{r + m^i n^j} z \\
\alpha ( \alpha^r z ) &=_\beta& \alpha^{r+1} z
\end{eqnarray*}

Hence $u[\encode{m} \encode{n}/x,y] =_\beta \alpha^p z$ where
$$ p = \sum_{0\leq k \leq d} m^{i_k} n^{j_k} + C$$
for some constant $C \in \nat$, $d\geq 0$ and $i_k,j_k \geq 0$ for $0 \leq k \leq d$. Thus $U \encode{m} \encode{n} =_\beta \encode{p}$.

Consequently, safe terms of type $I \rightarrow I \rightarrow I$ computes
exactly the polynomials of two variables.
\end{proof}

\begin{corollary}
The conditional operator $C:I\rightarrow I\rightarrow I \rightarrow I$ verifying the following equations:
\begin{eqnarray*}
C t y z &\rightarrow_\beta& y \mbox{, if } t \rightarrow_\beta \encode{0} \\
C t y z &\rightarrow_\beta& z \mbox{, if } t \rightarrow_\beta \encode{n+1}
\end{eqnarray*}
is not definable in the safe simply typed $\lambda$-calculus.
\end{corollary}

For instance, the term used in \cite{citeulike:622637} to define the conditional operator is
$$ C = \lambda F G H \alpha x . H ( \underline{\lambda y . G \alpha x} ) (F \alpha x) \ .$$
This term is indeed unsafe since the underlined term is of order $1$, occurs at an operand position and contains an occurrence of $x$ of order $0$.

Now suppose we are looking for a term $C$ behaving like a conditional but of type $I\rightarrow o\rightarrow o \rightarrow o$ instead. Note that in the lambda calculus, the definability of a conditional $C$ of type $I\rightarrow I\rightarrow I \rightarrow I$ implies the definability of a conditional $C'$ of type $I\rightarrow o\rightarrow o \rightarrow o$ (simply take $C' = \lambda t x y . (C t \encode{0} \encode{1}) (\lambda u . y) x$).
It  can be shown (using a proof similar to the proof of theorem \ref{thm:polychar}) that a term $M:I\rightarrow o\rightarrow o \rightarrow o$  is safe if and only if $M =_\beta \lambda t x y . x$  or $M =_\beta \lambda t x y . y$. Hence a conditional of type $I\rightarrow o\rightarrow o \rightarrow o$ does not exist either in the Safe $\lambda$-calculus.




\section{Decidability of observational equivalence for order 2 fragments}

\subsection{The queue-halting problem}
We fix a finite alphabet $\Sigma = \{ a_1, \ldots, a_p \}$. A queue program is a finite sequence of instructions that manipulate a queue data-structure.
A program $P$ is a sequence of $n$ instructions for some $n\in \nat$. For $1 \leq i \leq n$, $P i$ denotes the $i^{\sf th}$ instruction of the sequence $P$. There are four possible kinds of instruction: halting, enqueuing, dequeuing and branching. The set of instructions is formally defined as:
$$ \mathcal{I} = \{ {\tt halt} \} \cup
\{ {\tt enqueue \ } a \ | \ a \in \Sigma \}
\cup \{ {\tt dequeue} \} \cup \{ {\tt goto\ } l {\tt\ if\ first =\ } a \ | \ l \in 1..n, a \in \Sigma \}
 $$


The operational semantics is described using a set of states $ \{ \eop \} \cup \{ 1,..,n \} \times \Sigma^* $. The state $\eop$ corresponds to the final state at which the program stops. A state of the form $(i,x) \in \{ 1,..,n \} \times \Sigma^*$ indicates that the queue's content is given by the sequence $x$ and that the next instruction to be executed by the machine is $P i$. The empty queue is denoted by $\epsilon$ and for any sequence $x \in \Sigma^*$, the first element of $x$ corresponds to the element that has been \emph{first} enqueued (i.e. the queue is fed at the right-end side and consumed at the left-end side). The rules defining the operational semantics are:
\begin{eqnarray*}
(i,x) \mbox{ with } P i = {\tt halt} &\longrightarrow& \eop \\
(i,x) \mbox{ with } P i = {\tt enqueue\ } a &\longrightarrow& (i+1,x \cdot a) \\
(i,\epsilon) \mbox{ with } P i = {\tt dequeue } &\longrightarrow& \eop \\
(i,a \cdot x) \mbox{ with } P i = {\tt dequeue } &\longrightarrow& (i+1,x) \\
(i,\epsilon) \mbox{ with } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (i+1,\epsilon) \\
(i,b \cdot x) \mbox{ with } a \neq b \mbox{ and } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (i+1,b \cdot x) \\
(i,a \cdot x) \mbox{ with } P i =  {\tt goto\ } l {\tt\ if\ first =\ } a &\longrightarrow& (l,a \cdot x)
\end{eqnarray*}

It is possible to show that the Queue-Halting problem (``Given a queue program, will it halt eventually?'') is undecidable by simulating Post's Tag Systems in Queue.

\subsection{Observational equivalence of infinitary 2nd-order Safe \pcf\ with $Y_1$ recursion}

We describe a transformation which, given a queue-program $P$, produces a \pcf\ term $M_P$ that simulates $P$ in the sense that $P \Downarrow$ if and only if $M_P \rightarrow^* \eop$.

We fix a distinguished element $\bot$ denoting the end of the queue. Let $\Sigma^\bot = \Sigma \cup \{ \bot \}$. We assume that an injective function $\encode{\underline{\ }}$ is defined that encodes  the
elements of $\Sigma^\bot$ into $\nat$. It can for instance be defined as follows:
\begin{eqnarray*}
\encode{\underline{\ }} : \Sigma^\bot &\longrightarrow& 0..p \\
 \bot &\mapsto& 0 \\
 a_k &\mapsto& k \ , \mbox{for } k \in 1..p \ .
\end{eqnarray*}

We say that a $\pcf$ term $M$ computes an infinite sequence $s \in {(\Sigma^\bot)}^\omega$ if and only if
$M k \betared^* \encode{s k}$ for all $k\in \nat$.

We now identify a queue content $s \in \Sigma^*$ with the infinite sequence $s \bot^\omega \in \Sigma^\omega$. In the \pcf\ program that we are about to define, a queue content $s \in \Sigma^*$ will be represented by a term $\hat{s}$ that computes $s \bot^\omega$.

Each instruction $c$ of $\mathcal{I}$ is encoded uniquely into a natural number $\encode{ c }$. The following table gives an example of such an injective function:
\begin{center}
\begin{tabular}{c|c|c|c|c}
$c \in \mathcal{I}$ & {\tt halt} & {\tt dequeue } & {\tt enqueue} $a_i$ &  {\tt goto} l {\tt if first=} $a_i$ \\ \hline
$\encode{ c } \in \nat$ & $0$ & $1$ & $1+i$ & $1+p + n.l +i$ \\
\end{tabular}
\end{center}
where $1 \leq i \leq p, 1 \leq l \leq n$.

Let us fix a queue-program $P$ with $n$ instructions.
The code of $P$ is compiled into the following \pcf\ program $\hat{P}$
which maps an index $i$ to the encoding of the $i^{\sf th}$ instruction of $P$:
\begin{equation}
\hat{P} = \lambda i .  {\sf match\ } i {\sf \ with\ }
   0 \rightarrow \encode{ P 0 }
  \ | \ldots \ | n \rightarrow \encode{ P n }  | \_ \rightarrow \encode{\bot}
\end{equation}

We now define a \pcf\ program which interprets the queue-program $P$ given  its compiled form $\hat{P}$.
\begin{eqnarray*}
SIM = Y ( \lambda f i x . {\sf match\ } \hat{P} i  {\sf \ with\ }   \\
 \encode{ \tt halt }&\rightarrow& \encode{\eop} \\
| \encode{ {\tt enqueue\ } a_1 } &\rightarrow& f (i+1) ( \lambda j . {\sf if} j = \underline{\sf length}\ x\ {\sf then\ } \encode{a_1} {\sf\ else\ } x j ) \\
| \ldots \\
| \encode{ {\tt enqueue\ } a_p } &\rightarrow& f (i+1) ( \lambda j . {\sf if} j = \underline{\sf length}\ x\ {\sf then\ } \encode{a_p} {\sf\ else\ } x j ) \\
| \encode{ {\tt dequeue } } &\rightarrow& f (i+1) (\lambda j . x (j+1) ) \\
| \encode{ {\tt goto\ } l {\tt\ if\ first=\ } a_1 } &\rightarrow&
{\sf if\ } \underline{\sf length}\ x = 0 {\ \sf then\ } f (i+1) x \\
&&{\sf else\ if\ } \encode{a_1} = x 0 {\sf\ then\ } f l x \\
&&{\sf else\ } f (i+1) x \\
| \ldots \\
| \encode{{\tt goto\ } l {\tt\ if\ first=\ } a_p} &\rightarrow&
{\sf if\ } \underline{\sf length}\ x = 0 {\ \sf then\ } f (i+1) x \\
&&{\sf else\ if\ } \encode{a_p} = x 0 {\sf\ then\ } f l x \\
&&{\sf else\ } f (i+1) x \\
)\ 0\ (\lambda j . 0)
\end{eqnarray*}

where $f: (o,(o,o),o)$, $i:o$, $x:(o,o)$ and $\encode{\eop}$ is defined to be some \pcf\ natural number constant.
$$ \underline{\sf  length}  = Y( \lambda f x k . {\sf if\ } x k = \encode{\bot} {\sf\ then\ } 0 {\sf\ else\ } 1 + (f x (k+1)))$$

Note that the test of equality of two natural numbers is definable in $\pcf_2$ since the substraction operation is  also definable (by recursion). Moreover, it is easy to verify that the corresponding term is safe.


It is easy to show that $SIM \betared^* \encode{\eop}$ if and only if $P \rightarrow^* \eop$. Therefore since $SIM$ is a 2nd-order safe $\pcf$
(non-finitary since variable $i$ is unbounded) term, we have the following result:
\begin{theorem}
Observational equivalence for 2nd-order Safe $\pcf$ with $Y_1$ recursion and unbounded base types is undecidable.
\end{theorem}
Since $SIM$ is also an $\ialgol$ term, we have:
\begin{corollary}
Observational equivalence for 2nd-order Safe $\ialgol$ with $Y_1$ recursion and unbounded base types is undecidable.
\end{corollary}

This result is not really surprising. In fact it is easy to show that the partial recursive functions can be computed in this fragment of $\ialgol$, therefore it is a Turing-complete language. Hence observational equivalence is undecidable.


\subsection{Observational equivalence for finitary $\pcf_2 + Y_1$}

We will now see that in fact the previous result also hold in the
finitary case. Indeed, Ong showed in \cite{Ong02} that
observational equivalence for finitary second-order \ialgol\ with
recursion ($\ialgol_2 + Y_1$) is undecidable:
\begin{theorem}[Ong, LICS 2002]
Assuming that base types are finite, observational equivalence of 2nd-order IA with recursion is undecidable.
\end{theorem}

The proof proceeds by reduction of the Queue-Halting problem to the
observational equivalence of two $\ialgol_2 + Y_1$ programs: given a
Queue program $P$, a $IA_2 + Y_1$ term $M_P$ is defined such that
$M_P$ simulates $P$. $P$ terminates if and only if $M_P$ is
equivalent to $\iaskip$.

It happens that the term $M_P$ defined by Ong is a safe term
therefore:
\begin{corollary}
Assuming that base types are finite, observational equivalence of 2nd-order Safe IA with recursion is undecidable.
\end{corollary}

\subsection{Relation with the 2-DPDA equivalence problem}

The simply-typed $\lambda$-calculus augmented with the
$Y$-combinator written $\lambda^\rightarrow + Y$ is as expressive as
recursion schemes in the sense that any \emph{ground type} term of
$\lambda^\rightarrow + Y$ with redexes of order $n$ at most can be
encoded into an order-$n$ recursion scheme (furthermore, the
transformation is such that safe terms correspond to safe recursion
schemes). For example, take the ground type term $s^n z$ where
$s:o\rightarrow o$, $z :o$ for some natural number $n$. This term
can be transformed into the recursion scheme containing a single
equation $S = s^n z$. The value tree of this recursion scheme is a
flat tree over the alphabet $\Sigma = \{s:o\rightarrow o, z:o\}$
where nodes are labelled $s$ and leaves are labelled $z$.


Suppose that we are able to do the same for any \pcf\ term, then we
could convert $SIM$ into an equivalent safe recursion scheme. And
since order-$n$ safe recursion schemes are as expressive as
$n$-DPDA\footnote{Ssee \cite{KNU02} where an effective
transformation in both directions is given.}, we could build a
2-DPDA computing $SIM$ as well as a 2-DPDA computing
$\encode{\eop}$. But since Queue-Halting is undecidable, this would
imply the undecidability of 2-DPDA equivalence!\footnote{Equivalence
of 1-DPDA was shown to be decidable but it is still not known
whether it is the case at higher orders.}

Instead of trying to encode  \pcf\ terms into recursion schemes, we
can look at the equivalent problem of simulating \pcf\ constructs in
$\lambda^\rightarrow + Y$. It is well-known that the Church Numeral
representation does not permit to represent the predecessor function
in $\lambda^\rightarrow$ \cite{DBLP:journals/jacm/FortuneLO83}. It
is however possible to represent the predecessor function provided
that we allow a different representation of input and output numbers
\cite{DBLP:journals/jacm/FortuneLO83}. Unfortunately, the
substraction function is not definable in $\lambda^\rightarrow$
(equivalently  the equality test function $\lambda xy. {\sf if\ } x
= y {\sf\ then\ } u {\sf\ else\ } v$ is not definable)
\cite{DBLP:journals/jacm/FortuneLO83}. Hence we know that \pcf\
cannot be simulated into the simply-typed $\lambda$-calculus without
the $Y$ combinator.

Would the $Y$ combinator help to simulate the \pcf\ constructs? It
does not seem so. Indeed, as we have just seen, substraction --
which is definable in $\pcf$ using recursion and the conditional
operator -- is not definable in $\lambda^\rightarrow$. Throwing in
the recursion can be useful only if we have some destruction
function, such as the predecessor function. Indeed, only this can
permit us to make recursive call with decreasing parameters (which
is necessary to guarantee termination). Therefore we are bound to
use a numeral representation that can differ from input to output.
In other words, the type of the input may differ from the type of
the output. But with such difference in the representation,
recursion cannot be used anymore! Note that this problem is due to
the fact that \pcf\ uses simple types. With other kinds of types,
for instance second-order types, it would be possible to encode the
substraction operation.

%Suppose that equality test is definable by recursion by an the expression of  the form  $Y (\lambda f x y . e)$.
%
%A \emph{recursive call} in $e$ is an occurrence of $f$ in $e$.
%A recursive call is \emph{decreasing} if it is of the form $f t_x t_y$ where $t_x$ and $t_y$ denote $\lambda$-expressions in which $x$ and $y$ may occur free and such that for all $n_x, n_y \in \nat$: $t_x [\encode{n_x},\encode{n_x} /x,y] \betared^* \encode{m_x}$ and $t_y[\encode{n_x},\encode{n_x} /x,y] \betared^* \encode{m_y}$ for some $m_x,m_y \in \nat$ with  $m_x < n_x \vee  m_y < n_y$.
%
%We can assume that all recursive calls $f t_x t_y$ are such that
%$t_x$ and $t_y$ depends either on $x$ or $y$ or both (otherwise the recursive call can just be replaced by the $\beta$-normal form of $Y (\lambda f x y . e) t_x t_y$).
%
%In order to guarantee termination, at least one of the recursive call to $f$ in $e$ must be decreasing. This suggests that in order to define $e$, one needs to have access to a deconstructing function such as the predecessor function. Such function can only be encoded if we allow input and output value to have different representations.

\bibliographystyle{plain}
\bibliography{../bib/gamesem,../bib/higherorder,../bib/lambdacalculus}


\end{document}
