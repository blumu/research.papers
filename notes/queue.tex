\documentclass{article}
\usepackage{pdfsync}
\usepackage{a4wide}
\usepackage{amsmath, amsthm, amssymb}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{prop}[thm]{Proposition}



\newcommand{\encode}[1]{\ulcorner #1 \urcorner}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}

\newcommand\eop{{\sf eop}}
\newcommand{\betared}{\rightarrow_\beta}

%pcf
\newcommand\ialgol{{\textsl{IA}}}
\newcommand\pcf{\textsl{PCF}}
\newcommand\pcfcond{\texttt{cond}}
\newcommand\pcfsucc{\texttt{succ}}
\newcommand\pcfpred{\texttt{pred}}

\newcommand\iaskip{\texttt{skip}}



\author{William Blum}
\title{que s ue encoding in the Safe Lambda Calculus}

\begin{document}
\maketitle
Now suppose we are looking for a term behaving like a conditional but of type $I\rightarrow o\rightarrow o \rightarrow o$ instead. In the lambda calculus we have the term $\lambda t x y . (C\,t\,\encode{0}\, \encode{1}) (\lambda u . \underline{y}) x$ but it is unsafe. In fact it can be shown that there is no such term in the safe lambda calculus simply because the only safe terms of type $I\rightarrow o\rightarrow o \rightarrow o$  are $\lambda t x y . x$  and $\lambda t x y . y$ up to $\alpha\beta\eta$-equivalence.
  


\section{Decidability of observational equivalence for order 2 fragments}



\subsection{Observational equivalence of infinitary 2nd-order Safe \pcf\ with $Y_1$ recursion}

We describe a transformation which, given a queue-program $P$, produces a Safe \pcf\ term $M_P$ that simulates $P$ in the sense that $P \Downarrow$ if and only if $M_P \rightarrow^* \eop$.

We fix a distinguished element $\bot$ denoting the end of the queue. Let $\Sigma^\bot = \Sigma \cup \{ \bot \}$. We assume that an injective function $\encode{\underline{\ }}$ is defined that encodes  the
elements of $\Sigma^\bot$ into $\nat$. It can for instance be defined as follows:
\begin{eqnarray*}
\encode{\underline{\ }} : \Sigma^\bot &\longrightarrow& 0..p \\
 \bot &\mapsto& 0 \\
 a_k &\mapsto& k \ , \mbox{for } k \in 1..p \ .
\end{eqnarray*}

We say that a $\pcf$ term $M$ \emph{computes} an infinite sequence $s \in {(\Sigma^\bot)}^\omega$ if and only if $M k =_\beta \encode{s k}$ for all $k\in \nat$. We now identify a queue content $s \in \Sigma^*$ with the infinite sequence $s \bot^\omega \in \Sigma^\omega$. A queue content $s \in \Sigma^*$ will be represented by a \pcf\ term $\hat{s}$ computing the sequence $s \bot^\omega$.

Each instruction $c$ of $\mathcal{I}$ is encoded uniquely into a natural number $\encode{c}$. The following table gives an example of injection $c\mapsto\encode{c}$:
\begin{center}
\begin{tabular}{c|c|c|c|c}
$c \in \mathcal{I}$ & {\tt halt} & {\tt dequeue } & {\tt enqueue} $a_i$ &  {\tt goto} l {\tt if first=} $a_i$ \\ \hline
$\encode{ c } \in \nat$ & $0$ & $1$ & $1+i$ & $1+p + n.l +i$ \\
\end{tabular}
\end{center}
where $1 \leq i \leq p, 1 \leq l \leq n$.

Let us fix a queue-program $P$ with $n$ instructions.
The code of $P$ is compiled into the following \pcf\ program $\hat{P}$
that given an index $i$ returns the encoding of the $i^{\sf th}$ instruction of $P$:
\begin{equation}
\hat{P} = \lambda i .  {\sf match\ } i {\sf \ with\ }
   0 \rightarrow \encode{ P\, 0 }
  \ | \ldots \ | n \rightarrow \encode{ P\, n }  | \_ \rightarrow \encode{\bot}
\end{equation}
where {\sf match} is just syntactic sugar for nested conditionals.

We now define a \pcf\ program that act as an interpreter for queue-programs given in compiled form.
\begin{eqnarray*}
SIM = Y ( \lambda f i x . {\sf match\ } \hat{P}\, i  {\sf \ with\ }   \\
 \encode{ \tt halt }&\rightarrow& \encode{\eop} \\
| \encode{ {\tt enqueue\ } a_1 } &\rightarrow& f (i+1) ( \lambda j . {\sf if} j = \underline{\sf length}\ x\ {\sf then\ } \encode{a_1} {\sf\ else\ } x j ) \\
| \ldots \\
| \encode{ {\tt enqueue\ } a_p } &\rightarrow& f (i+1) ( \lambda j . {\sf if} j = \underline{\sf length}\ x\ {\sf then\ } \encode{a_p} {\sf\ else\ } x j ) \\
| \encode{ {\tt dequeue } } &\rightarrow& f (i+1) (\lambda j . x (j+1) ) \\
| \encode{ {\tt goto\ } l {\tt\ if\ first=\ } a_1 } &\rightarrow&
{\sf if\ } \underline{\sf length}\ x = 0 {\ \sf then\ } f (i+1) x \\
&&{\sf else\ if\ } \encode{a_1} = x 0 {\sf\ then\ } f l x \\
&&{\sf else\ } f (i+1) x \\
| \ldots \\
| \encode{{\tt goto\ } l {\tt\ if\ first=\ } a_p} &\rightarrow&
{\sf if\ } \underline{\sf length}\ x = 0 {\ \sf then\ } f (i+1) x \\
&&{\sf else\ if\ } \encode{a_p} = x 0 {\sf\ then\ } f l x \\
&&{\sf else\ } f (i+1) x \\
)\ 0\ (\lambda j . 0)
\end{eqnarray*}

where $f: (o,(o,o),o)$, $i:o$, $x:(o,o)$ and $\encode{\eop}$ is defined to be some \pcf\ natural number constant.
$$ \underline{\sf  length}  = Y( \lambda f x k . {\sf if\ } x k = \encode{\bot} {\sf\ then\ } 0 {\sf\ else\ } 1 + (f x (k+1)))$$

Note that the test of equality of two natural numbers is definable in $\pcf_2$ since the substraction operation is  also definable (by recursion). Moreover, it is easy to verify that the corresponding term is safe.

It is easy to show that $SIM \betared^* \encode{\eop}$ if and only if $P \rightarrow^* \eop$. We thus have:
\begin{theorem}
  Safe \pcf\ is Turing Complete.
\end{theorem}

Clearly, the observational equivalence problem is reducible to the \testsl{Halting} problem, therefore since $SIM$ is a 2nd-order safe $\pcf$ term, we have the following corollary:
\begin{corollary}
Observational equivalence for 2nd-order Safe $\pcf$ with $Y_1$ recursion (and unbounded base types) is undecidable.
\end{corollary}

\subsection{Observational equivalence for finitary $\pcf_2 + Y_1$}

We will now see that in fact the previous result also hold in the
finitary case. Indeed, Ong showed in \cite{Ong02} that
observational equivalence for finitary second-order \ialgol\ with
recursion ($\ialgol_2 + Y_1$) is undecidable:
\begin{theorem}[Ong, LICS 2002]
Assuming that base types are finite, observational equivalence of 2nd-order IA with recursion is undecidable.
\end{theorem}

The proof proceeds by reduction of the Queue-Halting problem to the
observational equivalence of two $\ialgol_2 + Y_1$ programs: given a
Queue program $P$, a $IA_2 + Y_1$ term $M_P$ is defined such that
$M_P$ simulates $P$. $P$ terminates if and only if $M_P$ is
equivalent to $\iaskip$.

It happens that the term $M_P$ defined by Ong is a safe term
therefore:
\begin{corollary}
Assuming that base types are finite, observational equivalence of 2nd-order Safe IA with recursion is undecidable.
\end{corollary}

\subsection{Relation with the 2-DPDA equivalence problem}

The simply-typed $\lambda$-calculus augmented with the
$Y$-combinator written $\lambda^\rightarrow + Y$ is as expressive as
recursion schemes in the sense that any \emph{ground type} term of
$\lambda^\rightarrow + Y$ with redexes of order $n$ at most can be
encoded into an order-$n$ recursion scheme (furthermore, the
transformation is such that safe terms correspond to safe recursion
schemes). For example, take the ground type term $s^n z$ where
$s:o\rightarrow o$, $z :o$ for some natural number $n$. This term
can be transformed into the recursion scheme containing a single
equation $S = s^n z$. The value tree of this recursion scheme is a
flat tree over the alphabet $\Sigma = \{s:o\rightarrow o, z:o\}$
where nodes are labelled $s$ and leaves are labelled $z$.


Suppose that we are able to do the same for any \pcf\ term, then we
could convert $SIM$ into an equivalent safe recursion scheme. And
since order-$n$ safe recursion schemes are as expressive as
$n$-DPDA\footnote{Ssee \cite{KNU02} where an effective
transformation in both directions is given.}, we could build a
2-DPDA computing $SIM$ as well as a 2-DPDA computing
$\encode{\eop}$. But since Queue-Halting is undecidable, this would
imply the undecidability of 2-DPDA equivalence!\footnote{Equivalence
of 1-DPDA was shown to be decidable but it is still not known
whether it is the case at higher orders.}

Instead of trying to encode  \pcf\ terms into recursion schemes, we
can look at the equivalent problem of simulating \pcf\ constructs in
$\lambda^\rightarrow + Y$. It is well-known that the Church Numeral
representation does not permit to represent the predecessor function
in $\lambda^\rightarrow$ \cite{DBLP:journals/jacm/FortuneLO83}. It
is however possible to represent the predecessor function provided
that we allow a different representation of input and output numbers
\cite{DBLP:journals/jacm/FortuneLO83}. Unfortunately, the
substraction function is not definable in $\lambda^\rightarrow$
(equivalently  the equality test function $\lambda xy. {\sf if\ } x
= y {\sf\ then\ } u {\sf\ else\ } v$ is not definable)
\cite{DBLP:journals/jacm/FortuneLO83}. Hence we know that \pcf\
cannot be simulated into the simply-typed $\lambda$-calculus without
the $Y$ combinator.

Would the $Y$ combinator help to simulate the \pcf\ constructs? It
does not seem so. Indeed, as we have just seen, substraction --
which is definable in $\pcf$ using recursion and the conditional
operator -- is not definable in $\lambda^\rightarrow$. Throwing in
the recursion can be useful only if we have some destruction
function, such as the predecessor function. Indeed, only this can
permit us to make recursive call with decreasing parameters (which
is necessary to guarantee termination). Therefore we are bound to
use a numeral representation that can differ from input to output.
In other words, the type of the input may differ from the type of
the output. But with such difference in the representation,
recursion cannot be used anymore! Note that this problem is due to
the fact that \pcf\ uses simple types. With other kinds of types,
for instance second-order types, it would be possible to encode the
substraction operation.

%Suppose that equality test is definable by recursion by an the expression of  the form  $Y (\lambda f x y . e)$.
%
%A \emph{recursive call} in $e$ is an occurrence of $f$ in $e$.
%A recursive call is \emph{decreasing} if it is of the form $f t_x t_y$ where $t_x$ and $t_y$ denote $\lambda$-expressions in which $x$ and $y$ may occur free and such that for all $n_x, n_y \in \nat$: $t_x [\encode{n_x},\encode{n_x} /x,y] \betared^* \encode{m_x}$ and $t_y[\encode{n_x},\encode{n_x} /x,y] \betared^* \encode{m_y}$ for some $m_x,m_y \in \nat$ with  $m_x < n_x \vee  m_y < n_y$.
%
%We can assume that all recursive calls $f t_x t_y$ are such that
%$t_x$ and $t_y$ depends either on $x$ or $y$ or both (otherwise the recursive call can just be replaced by the $\beta$-normal form of $Y (\lambda f x y . e) t_x t_y$).
%
%In order to guarantee termination, at least one of the recursive call to $f$ in $e$ must be decreasing. This suggests that in order to define $e$, one needs to have access to a deconstructing function such as the predecessor function. Such function can only be encoded if we allow input and output value to have different representations.

\bibliographystyle{plain}
\bibliography{../bib/gamesem,../bib/higherorder,../bib/lambdacalculus}


\end{document}
