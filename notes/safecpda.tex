\documentclass[a4paper]{article}
\usepackage{gamesem}
\usepackage{todonotes}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[defblank]{paralist}
\usepackage{shadowbox}
\usepackage{a4wide}
\usepackage{manfnt}
\usepackage{pdfsync}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]

\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]
\newtheorem{property}{Property}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{algorithm}{Algorithm}[section]

% order-decomposition of a 1-stack
\newcommand\orddec{\sf orddec}
\newcommand\sig{\sf sig}

\author{William Blum}
\title{Encoding of a safe order-$n$ recursion scheme into a $n$-PDA}

\begin{document}
\maketitle
\todo{ The proof presented in this note is incomplete (I have not managed to show Lemma \ref{lem:incrk_qsafe}) so the simulation may just be wrong...}

\begin{abstract}
Hague, Murawski, Ong and Serre \cite{hmos-lics08} introduced
higher-order collapsible pushdown automata (CPDA) and showed their
equivalence with higher-order recursion scheme. They proposed an
algorithm that transforms a given order-$n$ recursive  scheme G to
an equivalent order-$n$ CPDA. Here we show that if the recursion
scheme is safe then the generated automaton can in fact be simulated by an order
$n$ (non-collapsible) push-down automaton (PDA). The proof does not make
use of the type-homogeneity constraint. This contrasts with the original proof
of equi-expressivity (in term of generated trees) of PDAs and safe recursion schemes \cite{KNU02}.
\end{abstract}




\section{The HORS to HOCPDA encoding}

We fix a higher-order recursion scheme $G$ of order $n$.
We consider the $n$-CPDA $CPDA(G)$ constructed from $G$ as defined in Hague et al.'s paper \cite[Definition 5.2]{hague-collaps-full}.
Recall that the stack-alphabet $\Gamma$ is defined as the set of nodes of the computation graph $Gr(G)$ of $G$.

The purpose of the CPDA $CPDA(G)$ is to compute the set of traversals of the computation tree of $G$. One can easily transform $CPDA(G)$ into an automaton that ``prints out'' the traversal that is being computed. This can be done by changing the behaviour of the $push_1$ operation to make it print out the input element before pushing it on the stack. The justification pointers can then be recovered
inductively using the node labels: to recover the justifier of a variable node, we just need to look for the only node-occurrence that binds it in the P-view at that point (which is computable by the induction hypothesis).
Prime lambda nodes always point to their immediate predecessor. For non-prime lambda nodes, the justifier is always the occurrence preceding the justifier of the variable node preceding the lambda node.

Since some of the transitions of the CPDA, such as $collapse$, are destructive, the current content of stack does not contain sufficient information in order to reconstruct the traversal that is being computed.
Nevertheless, two very useful pieces of information can be recovered from the configuration-stack: namely the O-view and the P-view of the traversal.

Let $c$ be a configuration. The \defname{long O-view},
\defname{O-view} and \defname{P-view} of the traversal that is currently computed by the configuration $c$, written respectively $\longoview{c}$, $\oview{c}$ and $\pview{c}$, can be recovered as follows:
\begin{compactitem}
\item Long O-view:
\begin{align*}
  \longoview{s} &= \epsilon & \mbox{if $top_1 s$ is undefined;} \\
      &=   \longoview{pop_1 s} \cdot top_1 s & \mbox{if $top_1\,s \in N_{\sf var}$, $top_1 s$ pointing to its immediate predecesor;} \\
      &=   \longoview{pop_1 s} \cdot top_1 s & \mbox{if $top_1\,s \in N_@$, $@$ having no pointer;} \\
      &=   \longoview{collapse\,s} \cdot top_1 s & \mbox{if $top_1\,s \in N_\lambda^{\sf prime}$, $top_1 s$ pointing to its immediate predecesor;} \\
      &=   \longoview{collapse\,s} \cdot top_1 s & \mbox{if $top_1\,s \in N_\lambda\setminus N_\lambda^{\sf prime}$, $top_1 s$ pointing to $\ip(\jp(collapse\,s))$.} \\
\end{align*}
\item The O-view is defined similarly to the long-O-view except that the calculation stops when an @-node is reached:
\begin{align*}
  \oview{s}  &=   top_1 s & \mbox{if $top_1 s \in N_@$, $@$ having no pointer;}
\end{align*}
\item As shown in the original paper, the P-view $\pview{s}$ is given by $top_2\,c$.
\end{compactitem}
\bigskip

We call \defname{configuration} any order-$n$ stack where $n$ is the order
of $CPDA(G)$ (which is also the order of the recursion scheme $G$).

The initial configuration of $CPDA(G)$ is $c_0 = push_1 \theroot \bot_n$
where $\theroot$ denote the root dummy lambda node $\lambda$ of the computation graph.

\section{Safe HORS to HOPDA encoding}

We now fix a {\bf safe} higher-order recursion scheme $G$ of order $n$.
By analysing the $n$-CPDA $CPDA(G)$, we show that it is possible to construct a higher-order PDA of order $n$ equivalent to $CPDA(G)$.


\subsection{Conventions}
We use the notion of reachability with respect to the $\rightarrow$-step relation introduced in the original paper\footnote{Recall that $c\rightarrow c'$
just if $c' = \delta(top_1 c)(c)$ where $\delta$ is the transition
function defined Hague et al.'s paper \cite[Figure 2]{hague-collaps-full}.}: a configuration is $\rightarrow$-reachable if it can be attained starting from the initial configuration $c_0$ by performing one or more applications of the steps (A), (S), (L), $(V_1)$, $(V_0)$ from the algorithm defining $CPDA(G)$.
Thus the intermediate configurations visited by the internal transitions within a step are not $\rightarrow$-reachable.
A configuration is said to be \defname{reachable} if it is $\rightarrow$-reachable or if it is visited by an internal transitions
within a step (A), (S), (L), $(V_1)$ or $(V_0)$ of $CPDA(G)$.

An element of the CPDA stack is usually written $a^{(j,k)}$ where $a\in \Gamma$ and the exponent $(j,k)$
encodes the pointer associated to the stack symbol. We observe that in $CPDA(G)$ when pushing a lambda-node $\lambda \overline{\xi}$ on the stack, the associated link is always of the form $(n-\ord{\lambda \overline{\xi}}+1, k)$, therefore the first component of the link is recoverable from the node itself. Because the $j$-component of a link cannot be changed once the element is pushed onto the stack, for any reachable stack of $CPDA(G)$, all the lambda nodes will have a $j$-component of the form given above.
Furthermore, since the collapse operation is only executed on stack whose top element is a lambda node, the $j$-component is in fact never used for non-lambda nodes.
Hence we can omit the $j$-component altogether when representing stack symbols:  we will write $\lambda \overline{\xi}^{k}$ to mean $\lambda \overline{\xi}^{(n-\ord{\lambda \overline{\xi}}+1,k)}$.

From now on we use the term ``stack'' to refer to a stack that is the sub-stack of some reachable configuration of $CPDA(G)$. This means that for the stacks that we consider, the above link-convention
can be used.

\todo{Add definition of stack prefix ``$s_{\prefixof m}$'' \cite{hmos-lics08}.}

\subsection{Incremental order-decomposition}

We first define the notion incremental order-decomposition for order-$1$ stack and we then generalize it to higher-order stack.

Let $s$ be a 1-stack. For any $l\in \nat$, $s$ can then be written
$$ s = u_{r+1} \cdot \lambda \overline{\eta}_r^{k_r} \cdot u_r \cdot
\ldots \cdot \lambda \overline{\eta}_1^{k_1} \cdot  u_1 $$
where
\begin{compactitem}
\item  $\lambda \overline{\eta}_1^{k_1}$ is the
last $\lambda$-node in $s$ with order strictly greater than $l$;

\item for $1 < l \leq r$, $\lambda
\overline{\eta}_l^{k_l}$ is the last $\lambda$-node in $s_{\prefixof
\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$ with order strictly
greater than $\ord{\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$,

\item  $r$ is defined as the smallest number such that
$s_{\prefixof \lambda \overline{\eta}_{r}^{k_{r}}}$ does not contain
any lambda-node of order strictly greater than $\lambda
\overline{\eta}_{r}^{k_{r}}$.
\end{compactitem}

\noindent In other words:
\begin{compactitem}
\item for $1 \leq k \leq r$, all the lambda-nodes occurring in $u_l$ have order
strictly smaller than $\ord{\lambda \overline{\eta}_l}$;
\item for $1\leq l<l'\leq r$ we have $\ord{\lambda \overline{\eta}_l^{k_l}}
< \ord{\lambda \overline{\eta}_{l'}^{k_{l'}}}$;
\item $r=0$ if and only if all the lambda node in $s$ have order $\geq l$.
\end{compactitem}

The subsequence $\lambda \overline{\eta}_r^{k_r} \ldots \lambda\overline{\eta}_1^{k_1}$ of $s$ consisting of the lambda-nodes $\lambda
\overline{\eta}_l^{k_l}$ defined above is called the \defname{incremental order-decomposition of the $1$-stack} $s$ {\bf with respect to} $l\in\nat$.
This sequence is uniquely determined for any given $l\in \nat$.

\smallskip

\emph{Convention:} In the original definition, the operation $top_i$ that returns the top $(i-1)$-stack of a higher-order stack, removes any dangling pointer resulting from the operation. Here, we suppose that $top_i$ is defined in such a way that all pointers are preserved. From an implementation viewpoint, since links are encoded as pairs of integers, this means that $top_i$ just returns an unmodified copy of the top $(i-1)$-stack. This convention allows us to
extend the definition of order-decomposition to higher-level stacks as follows:

\begin{definition}
The \defname{incremental order-decomposition of a higher-order stack} $s$ {\bf with respect to $l\in \nat$} (or
order-decomposition for short), written $\orddec_l(s)$, is defined as the order-decomposition of the top order-$1$  stack. Equivalently it can be defined as follows:
\begin{align*}
  \orddec_l(\epsilon) &= \epsilon \\
    \mbox{for } s\neq\epsilon\quad \orddec_l(s) &=     \orddec_{\ord{\lambda\overline{\eta}}}(s_{<\lambda\overline{\eta}}) \cdot \lambda\overline{\eta}^k \\
& \mbox{\quad where } \lambda\overline{\eta}^k \mbox{ is the last node in $top_2\,s$ with order $>l$\ .}
\end{align*}
The \defname{incremental order-decomposition} of $s$, written
$\orddec(s)$, is defined as:
$$
\orddec(s) = \orddec_{-1}(s) \ .
$$
\end{definition}

%\begin{definition} Let $s$ be a stack.
%The \defname{signature} $\sig(s)$ of $s$ is defined as:
%$$sig(s) = \left\{
%           \begin{array}{ll}
%             \orddec_{\ord(top_1\,s)}(s), & \hbox{if $top_1\,s \in N_@ \union N_{var}$;} \\
%             \orddec_{-1}(s) = \orddec_{\ord(top_1\,s)}(pop_1\,s) \cdot (top_1\,s), & \hbox{if $top_1\,s \in N_\lambda$.}
%           \end{array}
%         \right.$$
%\end{definition}
%
It follows immediately from the definition that:
\begin{equation}
l<l' \implies \orddec_{l'}(s) \prefixof \orddec_{l}(s)
\label{eqn_safe_prefix}\end{equation}
where $\prefixof$ denotes the sequence-prefix ordering.


\begin{lemma}
\label{lem:push1pop1_orderdecompo} Let $s$ be a (possibly higher-order) stack
such that $top_1\,s \in N_@ \union N_{var}$.
\begin{enumerate}[i.]
\item Suppose that the order-decomposition with respect to some $l\in\nat$ is $\orddec_l(s) = \langle \lambda
\overline{\eta}_r^{k_r}, \ldots, \lambda \overline{\eta}_1^{k_1}
\rangle$ then for any lambda node $a \in \Gamma$ and link $(j,k)$ we have
 $$ \orddec_l(push_1 a^{(j,k)}~s) = \left\{
                                       \begin{array}{ll}
\orddec_l(s), &\hbox{if $\ord{a}\leq l$;} \\
                                        \langle a^k \rangle, &  \hbox{if $\ord{a} \geq \ord{\lambda \overline{\eta}_r}$}; \\
                                         \langle \lambda \overline{\eta}_r^{k_r}, \ldots, \lambda
\overline{\eta}_i^{k_i}, a^k \rangle, & \hbox{otherwise, where $i = \min \{ i \ \in \{1..r\}| \ \ord{a} <
\ord{\lambda \overline{\eta}_i} \}$.}
                                       \end{array}
                                     \right.$$

%\item Suppose that the signature is $\sig(s) = \langle \lambda
%\overline{\eta}_r^{k_r}, \ldots, \lambda \overline{\eta}_1^{k_1}
%\rangle$ then for any lambda node $a \in \Gamma$ and link $(j,k)$ we have
% $$ \sig(push_1 a^{(j,k)}\,s) = \left\{
%                                       \begin{array}{ll}
%                                        \langle a^k \rangle, &  \hbox{if $\ord{a} \geq \ord{\lambda \overline{\eta}_r}$}; \\
%                                         \langle \lambda \overline{\eta}_r^{k_r}, \ldots, \lambda
%\overline{\eta}_i^{k_i}, a^k \rangle, & \hbox{otherwise, where $i = \min \{ i \ \in \{1..r\}| \ \ord{a} <
%\ord{\lambda \overline{\eta}_i} \}$.}
%                                       \end{array}
%                                     \right.$$

\item For any non-lambda node $a \in \Gamma$ and link $(j,k)$ we have
$$ \orddec(push_1\,a^{(j,k)}\,s) = \orddec(s) \ .$$

\item If $top_1 s$ is not a lambda-node then
$$ \orddec(pop_1\,s) = \orddec(s) \ .$$
\end{enumerate}
\end{lemma}
\begin{proof}
Follows immediately from the definition of  $\orddec_l(s)$.
%ii.\ follows from i.\
%and because by definition $\sig(push_1 a^{(j,k)}\,s) = \orddec_{-1}(push_1 a^{(j,k)}\,s)$.
\end{proof}



\begin{lemma}[Incremental binders are in the order-decomposition]
\label{lem:binder_in_ordecompos} Let $c$ be a $\rightarrow$-reachable
configuration of $CPDA(G)$ such that $top_1\,c$ is a variable $x$. Then
\begin{enumerate}[i.]
\item $\orddec(c)$ contains at least a node with order strictly greater than $\ord(x)$;
\item the last lambda node in $\orddec(c)$ verifying the first condition is precisely $x$'s binder.
\end{enumerate}
In other words, $x$'s binder is the last lambda node in $\orddec_{\ord x}(c)$.
\end{lemma}
\proof
\begin{enumerate}[i.]
\item The top $1$-stack of a $\rightarrow$-reachable configuration contains the P-view of some traversal whose last visited node is the $top_1$ symbol \cite[Corollary 8]{hague-collaps-full}; and
    the P-view of a traversal is exactly the path (in the unfolding of) the
    computation graph from the last visited node to
    the root \cite[Proposition 6]{OngLics2006}. Hence the binder of $x$, whose order
    is strictly greater than $\ord{x}$, occurs in the top $1$-stack.
    Consequently $\orddec(c)$ must contain at least one node of order strictly greater than $l$.

\item Since the recursion scheme is safe, $x$ is
 incrementally bound (see \cite{blumong:safelambdacalculus})
 which means that its binder is precisely the first $\lambda$-node in the
 path to the root in the computation tree with order strictly
 greater than $x$. \qed
\end{enumerate}
%% end of proof

\subsection{Stack safety}

\begin{definition}[Safe stack]
\label{dfn:safestack} Let $s$ be an order-$j$ non-empty stack for $j\geq1$ and $r
= |\orddec(s)|$.

We say that $s$ is \defname{safe} if it is $(-1)$-safe,
and $s$ is \defname{$l$-safe} iff
    \begin{enumerate}[1.]
    \item $\orddec_l(s) = \langle \lambda \overline\eta_r^1, \ldots ,
    \lambda \overline{\eta}_1^1 \rangle$ \ie the $k$-components in $\orddec_l(s)$ are all equal to $1$;

    \item for all $1 \leq q \leq r$ such that $n-\ord{\lambda \overline\eta_q}+1 \leq \ord{s}$,
    $collapse~s_{\prefixof \lambda\overline\eta_q}$ is safe.
    \end{enumerate}

\end{definition}

\begin{lemma}[Equivalent formulation]
The following formulations of safety are all equivalent:
\begin{enumerate}
\item Let $s$ be a non-empty stack with order-decomposition
$\orddec(s)= \langle \lambda \overline\eta_r^{k_r}, \ldots ,
    \lambda \overline{\eta}_1^{k_1} \rangle$.
Then $s$ is safe iif
\begin{compactitem}
    \item if $n-\ord{\lambda \overline\eta_1}+1 \leq \ord{s}$ then
    $collapse\, s_{\prefixof \lambda\overline\eta_1}$ is safe;
    \item  if $r\geq 2$,  $s_{\prefixof \lambda\overline\eta_2}$ is safe.
\end{compactitem}

\item An order-$1$ stack $s$ is safe if and only if $\orddec(s) = \langle \lambda \overline{\eta}_r^1, \ldots , \lambda \overline{\eta}_1^1 \rangle$ with $r\geq 1$;
a higher-order stack $s$ is safe iff $top_2\,s$ is safe and
for any lambda-node $\lambda\overline\eta \in \orddec(s)$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$, $collapse\, s_{\prefixof\lambda\overline\eta}$ is safe.

\end{enumerate}

\end{lemma}




As an immediate consequence of the definition we have:
\begin{lemma}
\label{lem:safe_imp_incprefixsafe}
\begin{enumerate}[(i)]
\item
  \mbox{$s$ is $l$-safe}, $l\geq -1$ $\implies \forall \lambda\overline\eta \in \orddec_l(s) :$ $s_{\prefixof \lambda\overline\eta}$ is safe.

\item
  \mbox{$s$ is $l$-safe}, $l\geq -1$ $\iff s_{\prefixof \lambda\overline\eta}$ is safe \mbox{where $\lambda\overline\eta$ is the last node in $\orddec_l(s)$.}
\end{enumerate}
\end{lemma}

\begin{lemma}[Collapse simulation]
\label{lem:safecollapsesimulation}
Let $s$ be a sub-stack of a reachable configuration of $CPDA(G)$.
If $\ord s \geq 2$ and $top_2\,s$ is safe or if $\ord s = 1$ and $s$ is safe then for any lambda node $\lambda\overline\eta$ in $\orddec(s)$ we have:
$$collapse\,s_{\prefixof\lambda\overline\eta} = pop_{n-\ord \lambda\overline\eta +1}\,s_{\prefixof\lambda\overline\eta} \ . $$
\end{lemma}
\begin{proof}
By definition of the $collapse$ operation, we have $collapse\,s = pop_j^k\,s$ where $(j,k)\in\nat\times\nat$ is the link attached to $top_1\,s$.
Since $s$ is a sub-stack of a reachable configuration, we have $j = n-\ord \lambda\overline\eta +1$, and since
$top_2\,s$ is safe and $\lambda\overline\eta$ belongs to the order-decomposition, the $k$-component is necessarily equal to $1$.
\end{proof}


\subsubsection*{Operations preserving stack safety}
\begin{lemma}
\label{lem:push1pop1_preserves_safety} Let $s$ be a safe higher-order
stack. Then:
\begin{enumerate}
    \item $top_{\ord{s}}\,s$ is safe;

  \item if $top_1\,s$ is not a lambda-node then $pop\,s$ is safe;
  \item for any non-lambda node symbol $a$, $1 \leq j \leq n$, $k \geq 1$, $push_1\,a^{(j,k)}\,s$ is safe;
  \item for any lambda-node symbol $a$, $push_1\,a^{(n-\ord{a}+1,1)}\,s$ is safe.
\end{enumerate}
\end{lemma}
\begin{proof}
This is a direct consequence of Lemma
\ref{lem:push1pop1_orderdecompo}.
\end{proof}



Let $s$ be a higher-order stack. We define $s^{\langle j \rangle}$ as the operation that replaces
every link occurring in $s$ of the form $(j,k)$ by $(j,k+1)$. Formally,
\begin{align*}
{a^{(j,k)}}^{\langle j \rangle} &= a^{(j,k+1)}   \\
{a^{(j,k)}}^{\langle j' \rangle} &= a^{(j,k)} &   \mbox{when $j\neq j'$,}\\
[s_1 \ldots s_p]^{\langle j \rangle} &= [s_1^{\langle j \rangle} \ldots s_p^{\langle j \rangle}] \ .
\end{align*}
This operation clearly commutes with prefixing. We will therefore write $s^{\langle j\rangle}_{\prefixof m}$ as an abbreviation for
$(s^{\langle j\rangle})_{\prefixof m} = (s_{\prefixof m})^{\langle j\rangle}$,
for all stack $s$ and stack-symbol $m$ occurring in $s$.

\begin{lemma}
\label{lem:incrk_qsafe}
Let $0\leq l < n$ and $s$ be a stack of level $1\leq \ord{s} <n$.
If $s$ is safe then $s^{\langle n-l+1 \rangle}$ is $l$-safe.
\end{lemma}
\proof  Let $s$ be a safe stack with $1\leq \ord s <n$. We prove the result by induction on the size of $s$.
Base case: $s$ is the initial stack and the result holds trivially.

Step case: Since $s$ is safe we have
$\orddec(s) = \langle \lambda \overline{\eta}_r^1
, \ldots, \lambda \overline{\eta}_1^1   \rangle$.
By Eq.\ \ref{eqn_safe_prefix}, $\orddec_l(s)$ is a prefix of $\orddec(s)$.
Let $b$ be the index in $\orddec(s)$ of the last node of $\orddec_l(s)$
(thus $\lambda\overline\eta_b$ is the last node in $top_2\, s$ with order $>l$).

By definition, the operation $(\cdot)^{\langle n-l+1 \rangle}$ updates the pointers as follows:
the $k$-component of each link is increased by one if the order of
the stack symbol is $l$ and is kept unchanged otherwise.
Consequently:
\begin{equation*}
\orddec(s^{\langle n-l+1 \rangle}) = \langle
\lambda \overline{\eta}_r^1, \ldots,  \lambda \overline{\eta}_{b}^1, \lambda \overline{\eta}_{b-1}^{k}, \lambda \overline{\eta}_{b-2}^1 \ldots,
 \lambda \overline{\eta}_1^{1} \rangle
\end{equation*}
for some $k\leq 2$. Therefore:
\begin{equation*}
\orddec_l(s^{\langle n-l+1 \rangle}) = \langle \lambda \overline{\eta}_r^1
, \ldots, \lambda \overline{\eta}_b^1 \rangle\ .
\label{eqn_ordec_l}
\end{equation*}
To complete the proof, we need to show that
for all $b\leq j \leq r$ such that $n-\ord{\lambda \overline{\eta}_{j}} +1 \leq \ord s$, $collapse\, s^{\langle n-l+1 \rangle}_{\prefixof \lambda \overline{\eta}_{j}}$ is safe. Let $j$ be such an index.

Suppose that $|s_{\prefixof \lambda\overline\eta_j}|<|s|$.
The stack $s_{\prefixof \lambda\overline\eta_j}$ is safe by Lemma \ref{lem:safe_imp_incprefixsafe}. Thus since $s_{\prefixof \lambda\overline\eta_j}$ is smaller than $s$ we can apply the induction hypothesis on $s_{\prefixof \lambda\overline\eta_j}$ which gives that $s_{\prefixof \lambda\overline\eta_j}^{\langle n-l+1\rangle}$ is $l$-safe. But by
Eq.\ \ref{eqn_ordec_l},  $\orddec_l(s_{\prefixof \lambda\overline\eta_j}^{\langle n-l+1\rangle})
= \orddec(s_{\prefixof \lambda\overline\eta_j}^{\langle n-l+1\rangle})$
therefore $s_{\prefixof \lambda\overline\eta_j}^{\langle n-l+1\rangle}$
is safe. Hence $collapse\, s_{\prefixof \lambda\overline\eta_j}^{\langle n-l+1\rangle}$ is safe.



Suppose that $|s_{\prefixof \lambda\overline\eta_j}|=|s|$ then $s_{\prefixof \lambda\overline\eta_j}=s$ and therefore $b=j=0$.

We have
\begin{align*}
  collapse(s_{\prefixof \lambda\overline\eta_j}^{\langle n-l+1\rangle})
  &= collapse(s^{\langle n-l+1\rangle}) \\
  &= pop_{n-\ord(top_1\, s)+1} s^{\langle n-l+1\rangle} \\
  &= (pop_{n-\ord(top_1\, s)+1} s)^{\langle n-l+1\rangle} \\
  &= (collapse\, s)^{\langle n-l+1\rangle}
\end{align*}
Since $s$ is safe, so is $collapse s$ and therefore by the I.H.,
$(collapse\, s)^{\langle n-l+1\rangle}$ is $l$-safe.
\unfinished{But this is not enough: we want to show that $(collapse s)^{\langle n-l+1\rangle}$ is safe, and not only $l$-safe!!!
}

Hence $s^{\langle n-l+1 \rangle}$ is $l$-safe. \qed
\smallskip

\begin{lemma}
\label{lem:cons_qsafety} Let $s$ be a higher-order stack of level $\geq 2$. If
\begin{enumerate}[1.]
\item $pop_{\ord{s}}\,s$ is safe;
\item and $top_{\ord{s}}\,s$ (of order $(\ord s-1)$) is safe,
\end{enumerate}
then $s$ is safe.
\end{lemma}
\proof
Let $s = [s_1 \ldots s_l~s_{l+1}]$ for some $l\geq0$.
We proceed by induction on  $top_{\ord{s}}\,s=s_{l+1}$.
The base case $s_{l+1} = \bot_{\ord{s}-1}$ is trivial.
Suppose that $s_{l+1}$ is not the empty stack. We show that $s$ is safe using the inductive definition of stack-safety \ie we show that $top_2\,s$ is safe and that for all lambda-node $\lambda \overline{\eta} \in \orddec(s)$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$, $collapse\,s_{\prefixof \lambda \overline{\eta}}$ is safe:
\begin{itemize}
\item First condition: If $\ord{s}=2$ then $top_2\,s = top_{\ord s}\,s$ which is safe by the second assumption. Otherwise $\ord{s}>2$ and since $top_{\ord{s}} s$ is safe, so is $top_2(top_{\ord{s}} s)$. By definition of $top_2$ we have $top_2\,s = top_2(top_{\ord{s}}\, s)$ hence $top_2\,s$ is safe.

\item Second condition: Let $\lambda \overline{\eta}$ be a lambda-node in $\orddec(s) = \orddec(s_{l+1})$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$.
Since $top_2\,s$ is safe, by Lemma \ref{lem:safecollapsesimulation} we have
$collapse~s_{\prefixof \lambda \overline{\eta}} = pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof \lambda \overline{\eta}}$.

If $n-\ord{\lambda \overline{\eta}}+1 = \ord{s}$ then
$pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof \lambda \overline{\eta}} = pop_{\ord{s}}~s_{\prefixof\lambda\overline\eta} = pop_{\ord{s}}~s$ which is safe by the first assumption.

Otherwise $n-\ord{\lambda \overline{\eta}}+1 < \ord{s}$ and we have:
\begin{align*}
  collapse~s_{\prefixof\lambda\overline\eta}
      &= pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof\lambda\overline\eta}
      & \mbox{by Lemma \ref{lem:safecollapsesimulation}, since $s_{\prefixof\lambda\overline\eta}$ is safe} \\
  &= [ s_1 \ldots s_l\ (pop_{n-\ord{\lambda\overline\eta}+1}~ {s_{l+1}}_{\prefixof\lambda\overline\eta}) ]
   & \mbox{$n-\ord{\lambda \overline{\eta}}+1<\ord{s}$}  \\
  &= [s_1 \ldots s_p\ (collapse\, {s_{l+1}}_{\prefixof\lambda\overline\eta}) ]
  & \mbox{by Lemma \ref{lem:safecollapsesimulation}, since $s_{l+1}$ is safe}
\end{align*}

By the second assumption, $s_{l+1} = top_{\ord{s}}\,s$ is safe therefore by definition
of safety so is $collapse~{s_{l+1}}_{\prefixof\lambda\overline\eta}$, thus
since $|collapse~{s_{l+1}}_{\prefixof\lambda\overline\eta}| < |s_{l+1}|$ we can use the induction hypothesis which shows that $[s_1 \ldots s_p\ (collapse\, {s_{l+1}}_{\prefixof\lambda\overline\eta}) ]$ is safe.
\qed
\end{itemize}


We reproduce here the definition of the CPDA operation $push_j$ \cite{hmos-lics08}:
$$ push_j \underbrace{[ s_1 \ldots s_{l+1} ]}_{s} =
\left\{
  \begin{array}{ll}
\    [s_1\ \ldots\ s_{l+1}\ s_{l+1}^{\langle j \rangle}]  &\hbox{if $j = \ord{s}$;}\\
\    [s_1\ \ldots\ s_{l+1}\ push_j\ s_{l+1}]  &\hbox{if $j<\ord{s}$.}
 \end{array}
\right.
$$

\begin{lemma}
\label{lem:pushj_safe_implies_l-safe} Let $n>l\geq 0$ and $s$ be a safe higher-order stack such that $2 \leq n-l+1 \leq \ord{s} \leq n$. Then $push_{n-l+1}\ s$ is $l$-safe.
\end{lemma}
\proof
Let $s=[s_1 \ldots s_{c+1}]$ be a safe higher-order stack such that $2 \leq n-l+1 \leq \ord{s} \leq n$. Then by Lemma \ref{lem:push1pop1_preserves_safety}, $s_{c+1}$ is safe.

We show that $push_{n-l+1}~s$ is $l$-safe by finite induction on the order of $s$.
    \begin{compactitem}
      \item Base case: $\ord{s} = n-l+1 $. We have
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$.

    Since $s_{c+1}$ is safe,  by Lemma \ref{lem:incrk_qsafe} $s_{c+1}^{\langle n-l+1\rangle}$ is $l$-safe, and by Lemma
    \ref{lem:cons_qsafety},  $[ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$ is $l$-safe.

      \item Step case: $\ord{s} > n-l+1$. We have
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} push_{n-l+1}\,s_{c+1}]$.

    Since $s_{c+1}$ is safe, by the
    induction hypothesis $push_{n-l+1}~s_{c+1}$ is $l$-safe, and by Lemma \ref{lem:cons_qsafety} so is $[ s_1 \ldots s_{c+1} push_{n-l+1}\,s_{c+1}]$.
\qed
    \end{compactitem}
%end of proof





\section{Simulation and proof of correctness}
\begin{definition}[Simulating PDA]
Let $G$ be a safe recursion scheme.
We define $PDA(G)$ as the higher-order PDA obtained from
$CPDA(G)$ by replacing all the $collapse$ transitions by $pop_{n-\ord(top_1\,s)+1}$.
\end{definition}

\begin{proposition}
All the $\rightarrow$-reachable configurations of CPDA(G) are safe.
\end{proposition}
\proof
If $n =\ord{c} =1$ then the result holds trivially since CPDA(G) does not contain
any transition of the form $push_j$ for $j>1$ and therefore all the links associated to symbols in a configuration have a $k$-component equal to $1$.

Suppose that $n\geq 2$. We prove the result by induction on the number of
$\rightarrow$-steps. The initial configuration is trivially safe.
Suppose that $c$ is a safe $\rightarrow$-reachable configuration and that
$c \rightarrow c'$.
We show that $c'$ is safe by case analysis on $top_1\,c$:
\begin{itemize}
\item Case (A) Pushing @ on the top $1$-stack preserves safety (Lemma
\ref{lem:push1pop1_preserves_safety}), therefore $c'$ is safe.

\item Case (S)
We have $c' = push_1 a^{(n-\ord{a}+1,1)} c$ where $a$ is a
lambda-node, therefore by Lemma \ref{lem:push1pop1_preserves_safety},
$c'$ is safe.

\item Case (L) Again, Lemma \ref{lem:push1pop1_preserves_safety}
shows that (i) holds and (ii) trivially holds.

\item Case ($V_1$) \& ($V_0$) Suppose $u$ is labelled by a variable $x$ of order $l$.
Since $c$ is safe we have $\orddec(c) = \langle \lambda
\overline{\eta}_r^1 , \ldots, \lambda \overline{\eta}_1^1
\rangle$. Since the recursion-scheme $G$ is safe, by Lemma \ref{lem:binder_in_ordecompos}, $x$'s binder is precisely the
last node in $top_2\, c$ with order strictly greater than $l$ \ie the last node of $\orddec_l(c)$. Let $b$ be its index in $\orddec(c)$.


Case ($V_1$): $l\geq 1$.
The configuration $c'$ is given by $push_1\, E_i(top_1)^{(n-l+1,1)}\, t$ where
$t = (push_{n-l+1};pop_1^p;collapse)(c) = collapse \left( (push_{n-l+1}\,c)_{\prefixof \lambda
\overline{\eta}_{b}} \right)$.
By Lemma \ref{lem:pushj_safe_implies_l-safe} $push_{n-l+1}\, c$ is $l$-safe therefore
$t$ is safe and by Lemma \ref{lem:push1pop1_preserves_safety} so is $c'$.

Case ($V_0$): $l=0$ (which implies that  $b=0$). We have $c' = push_1 E_i(top_1)\,collapse(pop_1^p(c)) =
push_1 E_i(top_1)\,collapse(c_{\prefixof \lambda \overline\eta_b})$.
Since $c$ is safe, so is $collapse(c_{\prefixof \lambda \overline\eta_b})$ and
by Lemma \ref{lem:push1pop1_preserves_safety} so is $c'$.
\qed
\end{itemize}
%% end of proof
\smallskip

\begin{corollary}[Correctness of the simulation] \hfill
In CPDA(G), the $collapse$ operation is executed only on safe configurations.
\end{corollary}
\begin{proof}
In CPDA(G), the only occurrences of the collapse operation are in the steps ($V_1$) and ($V_0$). For ($V_1$) it is of the form:
$$ collapse(pop_1^p(push_{n-l+1}~c))$$
for some $\rightarrow$-reachable configuration $c$, where $top_1\,u$ is a variable of order $l$ and of span $p$. By the previous proposition,
$push_{n-l+1}\,c$ is $l$-safe where $b$ is the index of $x$'s binder in $\orddec(c)$. After performing $pop_1^p$, the top stack symbol is precisely $x$'s binder, therefore $pop^p_1(push_{n-l+1}~c)$ is safe.

The case ($V_0$) is similar.
\end{proof}

Together with Lemma \ref{lem:safecollapsesimulation}, this shows that $PDA(G)$ is equivalent to $CPDA(G)$.



\section{Remark}
It is possible to redefine the collapsible pushdown automaton $CPDA(G)$ from Hague et al.
\cite{hmos-lics08} in a more compact way by merging the two subcases in
$(V_1)$ and $(V_0)$. This is done as follows: In case (A), when
pushing the prime child of an application node $@$ on the stack, we
associate a link to it that points to the preceding stack symbol in
the top $1$-stack \ie the $@$-node itself.
 This modification permits us to avoid the consideration on $j$ (the child-index of $u$'s binder) in the
 cases ($V_0$) and ($V_1$). The sequences of instruction $pop_1^{p+1}$ can now be replaced by
 $pop_1^p ; collapse$. The resulting CPDA is denoted by $CPDA'(G)$ and is described in
Figure \ref{fig:cpdaprime}.
\begin{figure}
\begin{center}
\makebox{
\begin{shadowbox}[10cm]
If $u$'s label is not a variables, the action is just a $push_1^v$, where $v$ is an appropriate child of the node $u$. Precisely:
\begin{itemize}
\item $(A)$ If the label is an @ then $\delta(u) = push_1^{E_0(u),1}$.
\item $(S)$ \ldots
\item $(L)$ \ldots
\end{itemize}
Suppose $u$ is a variable which is the $i$-parameter of
its binder and let $p$ be the span of $u$.
\begin{itemize}
\item $(V_1)$ If the variable has order $l\geq 1$, then
$$\delta(u) = push_{n-l+1} ; pop_1^p ; collapse;push_1 E_i(top_1)^{(n-l+1,1)}$$
\item $(V_0)$ If the variable is of ground type then
$$\delta(u) = pop_1^p ; collapse;push_1 E_i(top_1)$$
\end{itemize}
\caption{CPDA'(G): a compact version of CPDA(G).}
\label{fig:cpdaprime}
\end{shadowbox}
}
\end{center}
\end{figure}
Contrary to $CPDA(G)$, in a configuration of this CPDA the link associated to a lambda node $\lambda\overline\eta$ is not necessarily of the form
$(n-\ord{\lambda\overline\eta}+1,k)$. Instead the first component of the link pair $(j,k)$ associated to a lambda node is defined as follows:
$j = 1$ if $\lambda\overline\eta$ is a prime node and $j=n-\ord{\lambda\overline\eta}+1$ otherwise. Therefore we can simulate the collapse operation
using transitions performing $pop_1$ if $top_1\, s$ is prime and $pop_{n-\ord{top_1(s)}+1}$ otherwise.


\bibliographystyle{abbrv}
\bibliography{../bib/dphil-all}

\end{document}
