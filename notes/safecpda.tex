\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[defblank]{paralist}
\usepackage{shadowbox}
\usepackage{a4wide}
\usepackage{manfnt}

\newcommand{\ord}{\mathop{\mathrm{ord}}}
\newcommand{\subseqof}{\sqsubseteq}
\newcommand{\prefixof}{\leqslant}
\newcommand{\suffixof}{\geqslant}
\newcommand\defname[1]{{\bf\em #1}\index{#1}}

\newcommand{\theroot}{\circledast} % the root of the computation tree

% misc
\newcommand\assignar\leftarrow

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]

\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]
\newtheorem{property}{Property}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{algorithm}{Algorithm}[section]

% order-decomposition of a 1-stack
\newcommand\orddec\overline


% ABBREVIATIONS
\def\ie{{\it i.e.}\ }
\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}

% set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\inter{\cap}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\prefset{\textsf{Pref}}
\newcommand{\relimg}[1]{{(\!| #1 |\!)}}
\newcommand\nat{\mathbb{N}}


% Note to myself
\newcommand\notetoself[1]{
\bigskip \noindent \fbox{
\begin{tabular}{cl}
\textdbend &
\begin{minipage}{0.80\textwidth}
#1
\end{minipage}
\end{tabular}
} }


\author{William Blum}
\title{Encoding of a safe order-$n$ recursion scheme into a $n$-PDA}

\begin{document}
\maketitle
\begin{abstract}
In \cite{hague-sto07}, Hague, Murawski, Ong and Serre introduced
higher-order collapsible pushdown automata (CPDA) and showed their
equivalence with higher-order recursion scheme. They proposed an
algorithm that transforms a given order-$n$ recursive  scheme G to
an equivalent order-$n$ CPDA. Here we show that if the recursion
scheme is safe then the generated automaton does not require the
extra power of a CPDA and can in fact be simulated by an order
$n$-PDA ({\it i.e.} push-down automaton). The proof does not make
use of the type-homogeneity constraint (\cite{KNU02}).
\end{abstract}


\section{Preliminaries}

Take an order-$n$ {\bf safe} recursion scheme $G$. Let $Gr(G)$ be the computation graph of $G$.
We consider the $n$-CPDA $CPDA(G)$ as defined in \cite[Definition 5.2]{hague-sto07}.
Recall that the stack-alphabet $\Gamma$ is defined as the set of nodes of the computation graph.
An element of the stack is written $a^{(j,k)}$ where $a\in \Gamma$ and the exponent $(j,k)$
encodes the pointer associated to the stack symbol. We observe that $CPDA(G)$ is such that the link associated to a lambda node $\lambda \overline{\xi}$ is always of the form $(n-\ord{\lambda \overline{\xi}}+1, k)$, therefore the first component of the link is always recoverable from the node itself. For this reason we omit it when representing stack symbols {\it i.e.} we write $\lambda \overline{\xi}^{k}$ to mean $\lambda \overline{\xi}^{(n-\ord{\lambda \overline{\xi}}+1,k)}$.


{\it Remark:} It is possible to redefine $CPDA(G)$ from
\cite{hague-sto07} in a more compact way by merging the subcases of
$(V_1)$ and $(V_0)$. This is done as follows: In case (A), when
pushing the prime child of an application node $@$ on the stack, we
associate a link to it that points to the preceding stack symbol in
the top $1$-stack {\it i.e.} the $@$-node itself.
 This modification permits us to avoid the consideration on $j$ (the child-index of $u$'s binder) in the
 cases ($V_0$) and ($V_1$). The sequences of instruction $pop_1^{p+1}$ can now be replaced by
 $pop_1^p ; collapse$. This gives us the CPDA $CPDA'(G)$ describe in
Figure \ref{fig:cpdaprime}.
\begin{figure}[htbp]
\begin{center}
\makebox{
\begin{shadowbox}[10cm]
Suppose $u$ is a variable which is the $i$-parameter of
its binder and let $p$ be the span of $u$.
\begin{itemize}
\item $(V_1)$ If the variable has order $l\geq 1$, then
$$\delta(u) = push_{n-l+1} ; pop_1^p ; collapse;push_1 E_i(top_1)^{(n-l+1,1)}$$
\item $(V_0)$ If the variable is of ground type then
$$\delta(u) = pop_1^p ; collapse;push_1 E_i(top_1)$$
\end{itemize}
\caption{CPDA'(G): a compact version of CPDA(G).}
\label{fig:cpdaprime}
\end{shadowbox}
}
\end{center}
\end{figure}
This definition is more compact, however it makes it harder to
understand how the CPDA works. We will therefore stick to the
original definition for the purpose of proving our result and we
will make an explicit case analysis on $j$ in the proof.

In the following, we use the term \defname{configuration} to refer to an order-$n$ stack where $n$ is the order
of the recursion scheme (which is also the order of CPDA(G)).


\subsection{Incremental order-decomposition}

Let $s$ be a 1-stack. It can then be written as
$$ s = u_{r+1} \cdot \lambda \overline{\eta}_r^{k_r} \cdot u_r \cdot
\ldots \cdot \lambda \overline{\eta}_1^{k_1} \cdot  u_1 $$
for some $r\geq 0$ where
\begin{compactitem}
\item  $\lambda \overline{\eta}_1^{k_1}$ is the
last $\lambda$-node in $s$ with order strictly positive;

\item for $1 \leq l \leq r$, $\lambda
\overline{\eta}_l^{k_l}$ is the last $\lambda$-node in $s_{\prefixof
\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$ with order strictly
greater than $\ord{\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$,

\item  $r$ is defined as the smallest number such that
$s_{\prefixof \lambda \overline{\eta}_{r}^{k_{r}}}$ does not contain
any lambda-node of order strictly greater than $\lambda
\overline{\eta}_{r}^{k_{r}}$.
\end{compactitem}

Thus:
\begin{compactitem}
\item for $1 \leq k \leq r$, all the lambda-nodes occurring in $u_l$ have order
strictly smaller than $\ord{\lambda \overline{\eta}_l}$;
\item For $l>l'$ we have $\ord{\lambda \overline{\eta}_l^{k_l}}
> \ord{\lambda \overline{\eta}_{l'}^{k_{l'}}}$;
\item We have $r=0$ iif there is no lambda node in $s$ with
positive order.
\end{compactitem}
\smallskip

We call \defname{incremental order-decomposition} (or just
order-decomposition) of $s$ and we write $\orddec{s}$ to denote the
subsequence $\lambda
\overline{\eta}_r^{k_r} \ldots \overline{\eta}_1^{k_1}$ of $s$ consisting of the lambda-nodes $\lambda
\overline{\eta}_l^{k_l}$ defined above. For $1\leq l \leq r$, $l$ is called the \defname{incremental index} of the lambda-node $\lambda \overline{\eta}_l^{k_l}$ in $\orddec{s}$.
 Note that this sequence is uniquely determined.

Convention: Usually the operation $top_i~s$, that returns the top $(i-1)$-stack of a higher-order stack $s$, does not preserve the dangling pointers resulting from the extraction of the stack. Here, we define $top_i$ in such a way that the pointers are preserved. In the implementation side, this just means that we keep the pair of integers that encodes each pointer. This convention allows us to
extend the definition of the order-decomposition to higher-level stacks as follows:
\begin{definition}
The incremental order-decomposition
of a higher-order stack $s$ is defined as the incremental
order-decomposition of $top_2 s$ \ie $\orddec{s} = \orddec{top_2~s}$.
\end{definition}


\begin{lemma}
\label{lem:push1pop1_orderdecompo} Let $s$ be a higher-order stack
with order-decomposition $\orddec{s} = \langle \lambda
\overline{\eta}_r^{k_r}, \ldots, \lambda \overline{\eta}_1^{k_1}
\rangle$. Then
\begin{enumerate}[i.]
\item For all lambda node $a \in \Gamma$ and link $(j,k)$ we have
 $$ \orddec{push_1 a^{(j,k)} s} = \left\{
                                       \begin{array}{ll}
                                        \langle a^k \rangle, &  \hbox{if $\ord{a} \geq \ord{\lambda \overline{\eta}_r^{k_r}}$}; \\
                                         \langle \lambda \overline{\eta}_r^{k_r}, \ldots, \lambda
\overline{\eta}_i^{k_i}, a^k \rangle, & \hbox{otherwise, where $i = \min \{ i \ | \ \ord{a} <
\ord{\lambda \overline{\eta}_i^{k_i}} \}$.}
                                       \end{array}
                                     \right.$$

\item For all non-lambda node $a \in \Gamma$ and link $(j,k)$ we have
$$ \orddec{push_1 a^{(j,k)} s} = \orddec{s} \ .$$

\item If $top_1 s$ is not a lambda-node then
$$ \orddec{pop_1 s} = \orddec{s} \ .$$
\end{enumerate}
\end{lemma}
\begin{proof}
  Trivial from the definition of  $\orddec{s}$.
\end{proof}


We use the notion of reachable configuration 
with respect to the $\rightarrow$-step relation introduced in the original paper.\footnote{Recall that $c\rightarrow c'$
just if $c' = \delta(top_1 c)(c)$ where $\delta$ is the transition
function defined in \cite[Figure 2]{hague-sto07}.} Thus a configuration of is reachable if it can be attained starting from the initial configuration (\ie $push_1 \theroot \bot_n$) by performing one or more application of the steps (A), (S), (L), $(V_1)$, $(V_0)$ of the algorithm defining $CPDA(G)$.
In particular, the intermediate configurations reached by the internal transitions within a step are not considered reachable.

\begin{lemma}[Incremental binders are in the order-decomposition]
\label{lem:binder_in_ordecompos} Let $c$ be a reachable
configuration of $CPDA(G)$ such that $top_1\
c$ is a variable $x$ of order $l\geq 0$. Then
\begin{enumerate}[i.]
\item $\orddec{c}$ contains at least a node with order strictly
greater than $l$;
\item The last lambda node in $\orddec{c}$ verifying the first condition is precisely $x$'s binder.
\end{enumerate}
\end{lemma}
\begin{proof}
\begin{enumerate}[i.]
\item By Corollary 8 from \cite{hague-sto07}, the $top_2$
     stack of a configuration contains the P-view of some
    traversal whose last visited node is the $top_1$ symbol, and
    by Proposition 6 from \cite{OngLics2006}, the P-view of a
    traversal is exactly the path from the last visited node to
    the root of the computation tree (obtained by unfolding the
    computation graph). Hence the binder of $x$, whose order
    is strictly greater than $\ord{x}$, occurs in $top_2 c$.
    Consequently $\orddec{c}$ must contain at least one node of order strictly greater than $l$.

\item Since the recursion scheme is safe, $x$ is
 incrementally bound (see \cite{blumong:safelambdacalculus})
 which means that its binder is the first $\lambda$-node in the
 path to the root in the computation tree with order strictly
 greater than $x$.
\end{enumerate}
\end{proof}

\subsection{Safe higher-order stack}
\subsubsection{Definition}

\begin{definition}[Safe higher-order stack]
\label{dfn:safestack} Let $s$ be an order-$j$ stack for $j\geq1$ and $r
= |\orddec{s}|$.
We say that $s$ is \defname{safe} iif
    \begin{enumerate}[1.]
    \item $\orddec{s} = \langle \lambda \overline{\eta}_r^1, \ldots ,
    \lambda \overline{\eta}_1^1 \rangle$ \ie the $k$-components in $\orddec{s}$ are all equal to $1$;
    \item for all $1 \leq q \leq r$ such that $n-\ord{\lambda \overline{\eta}_q}+1 \leq \ord{s}$, 
    $collapse~s_{\prefixof \lambda \overline{\eta}_q} = pop_{n-\ord{\lambda \overline{\eta}_q}+1}~s_{\prefixof \lambda \overline{\eta}_q}$ is safe.
    \end{enumerate}
We say that a stack $s$ is \defname{$q$-safe} iff $pop_1^{q-1} s$ is safe.
\end{definition}

Equivalently, this definition can be reformulated indictively as follows:
an order-$1$ stack $s$ is safe if and only if $\orddec{s} = \langle \lambda \overline{\eta}_r^1, \ldots , \lambda \overline{\eta}_1^1 \rangle$;
a higher-order stack $s$ is safe iff $top_2(s)$ is safe and
for any lambda-node $\lambda \overline{\eta} \in \orddec{s}$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$,
    $collapse~s_{\prefixof \lambda \overline{\eta}}$ is safe.


\subsubsection{Stack operations preserving stack safety}
\begin{lemma}
\label{lem:push1pop1_preserves_safety} Let $s$ be a safe higher-order
stack. Then:
\begin{enumerate}
  \item If $top_1\ s$ is not a lambda-node then $pop\ s$ is safe;
  \item for any non-lambda node symbol $a$, $1 \leq j \leq n$, $k \geq 1$, $push_1\ a^{(j,k)}\ s$ is safe;
  \item for any lambda-node symbol $a$, $push_1\ a^{(n-\ord{a}+1,1)}\ s$ is safe.
\end{enumerate}
\end{lemma}
\begin{proof}
This is a direct consequence of Lemma
\ref{lem:push1pop1_orderdecompo}.
\end{proof}


\begin{lemma}
\label{lem:top_qsafe} If $s$ is safe then $top_{\ord{s}}~s$ is safe.
\end{lemma}


Let $s$ be a higher-order stack. We define $s^{\langle j \rangle}$ as the operation that replaces
every link occurring in $s$ of the form $(j,k)$ by $(j,k+1)$. Formally,
\begin{align*}
{a^{(j,k)}}^{\langle j \rangle} &= a^{(j,k)}   \\
{a^{(j,k)}}^{\langle j' \rangle} &= a^{(j,k+1)} &   \mbox{when $j\neq j'$,}\\
[s_1 \ldots s_p]^{\langle j \rangle} &= [s_1^{\langle j \rangle} \ldots s_p^{\langle j \rangle}] \ .
\end{align*}

\begin{lemma}
\label{lem:incrk_qsafe}
Let $n>l\geq 0$. Let $s$ be a stack of level $1\leq \ord{s} <n$.
 Let $b$ be the incremental index of the last lambda node in $\orddec{s}$
 with order $>l$.
If $s$ is safe then $s^{\langle n-l+1 \rangle}$ is $b$-safe.
\end{lemma}
\begin{proof}
  By induction on the order of $s$.
The base case is $\ord{s} = 1$.
Since $s$ is safe we have:
\begin{equation}
 \orddec{s} = \langle \lambda \overline{\eta}_r^1
, \ldots, \lambda \overline{\eta}_1^1   \rangle \ . \label{eqn:orddec_s}
\end{equation}
By definition of the operation $s^{\langle n-l+1 \rangle}$, the pointers in $s = top_2\ s$ are updated as follows:
the $k$ component of each link is increased by one if the order of
the stack symbol is $l$ and is kept unchanged otherwise.
Hence we have:
\begin{equation}
\orddec{s^{\langle n-l+1 \rangle}} = \langle
\lambda \overline{\eta}_r^1, \ldots,  \lambda \overline{\eta}_{b}^1, \lambda \overline{\eta}_{b-1}^{k_{b-1}}, \ldots,
 \lambda \overline{\eta}_1^{k_1} \rangle
\ .
\end{equation}
for some $k_{b-1}, \ldots , k_1 \leq 2$ and where $q$ is precisely the incremental index of the last lambda-node in $\orddec{s}$ with order $>l$ \ie $q=b$. Thus $s^{\langle n-l+1 \rangle}$ is $b$-safe.

Step case: $n>\ord{s}>1$.
By definition of the order-decomposition we have
$\orddec{s^{\langle n-l+1 \rangle}} = \orddec{top_2 (s^{\langle n-l+1 \rangle})}$.
Clearly we have $top_2 (s^{\langle n-l+1 \rangle}) = (top_2 (s))^{\langle n-l+1 \rangle}$.
Since $s$ is safe so is $top_2(s)$, therefore by the base case of the induction we have that $top_2 (s^{\langle n-l+1 \rangle})$ is $b$-safe. To conclude that $s^{\langle n-l+1 \rangle}$ is also $b$-safe, we need to show the second condition of Def.~\ref{dfn:safestack},
that is to say for all $b\leq q \leq r$ such that
$n-\ord{\lambda \overline{\eta}_{q}} +1 \leq \ord{s^{\langle n-l+1 \rangle}}$, $collapse~s_{\prefixof \lambda \overline{\eta}_{q}}$ is safe.

This is clearly true. Indeed, the only symbols that are updated in $s$ by the operation $s \mapsto s^{\langle n-l+1 \rangle}$ are those occurring in the top order-$1$ stack $top_2~s$. Thus since the first $r-b+1$ lambda-nodes in $\orddec{s^{\langle n-l+1 \rangle}}$ and $\orddec{s}$ coincide, this implies that $collapse(pop_1^{q} s^{\langle n-l+1 \rangle}) = collapse(pop_1^q s)$ for all $b \leq q \leq r$.
Hence the safety of $s$ implies the safety of $pop_1^{q}~s^{\langle n-l+1 \rangle}$ \ie the $q$-safety of $s^{\langle n-l+1 \rangle}$.
\end{proof}



\begin{lemma}
\label{lem:cons_qsafety} Let $s$ be a higher-order stack of level $\geq 2$. If
\begin{enumerate}[1.]
\item $pop_{\ord{s}}~s$ is safe;
\item and $top_{\ord{s}}~s$ (of order $(\ord{s}-1)$) is safe,
\end{enumerate}
then $s$ is safe.
\end{lemma}
\begin{proof}
We use the inductive definition of safety: we show that $top_2~s$ is
safe and that for all lambda-node $\lambda \overline{\eta} \in \orddec{s}$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$, $collapse~s_{\prefixof \lambda \overline{\eta}}$ is safe.

The first part is clearly verified. Indeed, if $\ord{s}=2$ then $top_2~s = top_{\ord s}~s$ which is safe by the second assumption.
Suppose that $\ord{s}>2$. Since $top_{\ord{s}} s$ is safe, so is $top_2(top_{\ord{s}} s)$. By definition of $top_2$ we have $top_2~s = top_2(top_{\ord{s}} s)$ therefore $top_2~s$ is also safe.

For the second part: Let $\lambda \overline{\eta}$ be a lambda-node in $\orddec{s}$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$.
Since $top_2(s)$ is safe, the link associated to $\lambda \overline{\eta}$
has a $k$-component equal to $1$, therefore the $collapse$ operation can be simulated by a single $pop_{n-\ord{\lambda \overline{\eta}}+1}$ operation.

If $n-\ord{\lambda \overline{\eta}}+1 = \ord{s}$ then 
$pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof \lambda \overline{\eta}} = pop_{\ord{s}}~s_{\prefixof \lambda \overline{\eta}}$. This is in turn 
equal to $pop_{\ord{s}}~s$ which is safe by the first assumption.

Otherwise,

\notetoself{Old pieces of proof:
The stack symbols that are duplicated by the $push_j$ operation are
the ones lying in the $top$ order-$(j-1)$ stack. More precisely,
suppose $top_{j+1}\ c = [c_1\ \ldots\ c_{l+1}]$ then $top_{j+1}\
(push_j\ c) = [c_1\ \ldots\ c_{l+1}\ c_{l+1}^{\langle j \rangle}]$
and the elements that are created lies in $top_j\ (push_j\ c) =
c_{l+1}^{\langle j \rangle}$.

Take any such element $a^{(l,k)}$. If $l=j$ then the link points to
the same prefix stack as some other stack symbol in $top_j\ c$, thus
the induction hypothesis permits to conclude.

If $l \neq j$ then the link points somewhere in $top_j\ (push_j\ c)$
and in that case $top_2( collapse(c_{\prefixof{a}})) = top_2(
collapse( pop_{j+1} c_{\prefixof{a}}))$ so we can conclude by the
induction hypothesis.
}

\end{proof}


\begin{lemma}
\label{lem:pushj_safe_implies_b-safe} Let $n>l\geq 0$ and $s$ be a higher-order stack
of level $2 \leq n-l+1 \leq \ord{s} \leq n$. Let $b$ be the incremental index of the last lambda node in $\orddec{s}$ with order $>l$. Then $push_{n-l+1}\ s$ is $b$-safe.\footnote{We reproduce here the definition of the
CPDA operation $push_j$ from \cite{hague-sto07}:
$$ push_j \underbrace{[ s_1 \ldots s_{l+1} ]}_{s} =
\left\{
  \begin{array}{ll}
\    [s_1\ \ldots\ s_{l+1}\ s_{l+1}^{\langle j \rangle}]  &\hbox{if $j = \ord{s}$;}\\
\    [s_1\ \ldots\ s_{l+1}\ push_j\ s_{l+1}]  &\hbox{if $j<\ord{s}$.}
 \end{array}
\right.
$$}
\end{lemma}
\begin{proof}
Let $s=[s_1 \ldots s_{c+1}]$ be any safe higher-order stack of order. We show that $push_{n-l+1}~s$ is $b$-safe by finite induction on the order of $s$.
    \begin{compactitem}
      \item Base case: $\ord{s} = n-l+1 $. We have
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$.

    Since $s$ is safe, by Lemma \ref{lem:top_qsafe} so is $s_{c+1}$
    which in turn implies that $s_{c+1}^{\langle n-l+1\rangle}$ is
    $b$-safe by Lemma \ref{lem:incrk_qsafe}. Therefore by Lemma
    \ref{lem:cons_qsafety},  $[ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$ is $b$-safe.

      \item Step case: $\ord{s} > n-l+1$. We have
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} push_{n-l+1}~s_{c+1}]$.

    $s_{c+1}$ is safe by Lemma \ref{lem:top_qsafe} thus by the
    induction hypothesis $push_{n-l+1}~s_{c+1}$ is $b$-safe and therefore by Lemma \ref{lem:cons_qsafety} so
    is $[ s_1 \ldots s_{c+1} push_{n-l+1}~s_{c+1}]$.
    \end{compactitem}
\end{proof}





\section{Simulation}

We claim that provided that the input recursion scheme is safe, the
uses of the $collapse$ operation in $CPDA(G)$ can all be replaced by the operation $pop_{n-\ord{top_1(s)}+1}$. Equivalently, in the $CPDA'(G)$ formulation, the
$collapse$ instruction is replaced by transitions performing $pop_{n-\ord{top_1(s)}+1}$ if $top_1(s)$ is a $j$-child with $j\geq 2$ and $pop_1$ if it is a prime
child.

\section{Proof of correctness}

\begin{proposition}
All the reachable configurations of CPDA(G) are safe.
\end{proposition}
\begin{proof}
If $n =\ord{c} =1$ then the result holds trivially since CPDA(G) does not contain
any transition of the form $push_j$ for $j>1$ and therefore all the links associated to symbols in a configuration have a $k$-component equals to $1$.

Suppose that $n\geq 2$. We prove the result by induction on the number of
$\rightarrow$-steps. The initial configuration is trivially safe. 
Suppse that $c$ is a safe reachable configuration and that
$c'=\delta(u)(c)$ where $u = top_1\ c$.
We show that $c'$ is safe by case analysis on $u$:
\begin{itemize}
\item[Case (A)] Pushing @ on the top $1$-stack preserves safety (Lemma
\ref{lem:push1pop1_preserves_safety}), therefore $c'$ is safe.

\item Case (S)
We have $c' = push_1 a^{(n-\ord{a}+1,1)} c$ where $a$ is a
lambda-node, therefore by Lemma \ref{lem:push1pop1_preserves_safety},
$c'$ is safe.

\item Case (L) Again, Lemma \ref{lem:push1pop1_preserves_safety}
shows that (i) holds and (ii) trivially holds.

\item Case ($V_1$) Suppose $u$ is labelled by a variable $x$ of order $l\geq 1$.

Since $c$ is safe we have $\orddec{c} = \langle \lambda
\overline{\eta}_r^1 , \ldots, \lambda \overline{\eta}_1^1
\rangle$.
Since the recursion-scheme $G$ is safe, by Lemma \ref{lem:binder_in_ordecompos}, $x$'s binder is precisely the
last node in $\orddec{c}$ with order strictly greater than $l$.
Hence by Lemma \ref{lem:pushj_safe_implies_b-safe}
we have that $push_{n-l+1}\ c$ is $b$-safe where $b$ is the
incremental index of $x$'s binder in $\orddec{c}$.

Consequently by definition of $b$-safety we have that
$t = collapse \left( (push_{n-l+1}~ c)_{\prefixof \lambda
\overline{\eta}_{b}} \right) = (push_{n-l+1};pop_1^p;collapse)
c$ is safe. Finally by
Lemma \ref{lem:push1pop1_preserves_safety}, $c' = push_1 E_i(top_1)^{(n-l+1,1)}\ t$, is also safe.

\item ($V_0$) This case is treated identically to ($V_1$).
\end{itemize}
\end{proof}

\begin{corollary}
Whenever the $collapse$ operation is executed during a
transition $s \rightarrow collapse~s$, the $k$-component of the link attached to the symbol $top_1~s$ is equal to $1$.
\end{corollary}
\begin{proof}
  In CPDA(G), the only occurrences of the collapse operation are in the steps ($V_1$) and ($V_0$) and are of the form:
$$ collapse(pop_1^p(push_{n-l+1}~c))$$
for some reachable configuration $c$, where $top_1(u)$ is a variable of order $l$ and of span $p$. In the proof of the previous proposition, we have shown that
$push_{n-l+1}~c$ is $b$-safe where $b$ is the incremental index of $x$'s binder in $\orddec{c}$. 

After performing $pop_1^p$, the top stack symbol contains $x$'s
binder which is precisely the lambda-node with incremental index $b$. Therefore $pop^p_1(push_{n-l+1}~c)$ is safe. Hence the link attached to $top_1 (pop^p_1(push_{n-l+1}~c))$ has a $k$-component equal to $1$.
\end{proof}

By definition of the $collapse$ operation, for any stack $s$ if the link attached to $top_1(s)$ is $(j,k)$ then $collapse~s = pop_1^k~s$.
Togethere with the previous corollary, this shows the correctness of the simulation. 

\bibliographystyle{abbrv}
\bibliography{../bib/dphil-all}

\end{document}
