\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[defblank]{paralist}
\usepackage{shadowbox}
\usepackage{a4wide}
\usepackage{manfnt}

\newcommand{\ord}{\mathop{\mathrm{ord}}}
\newcommand{\subseqof}{\sqsubseteq}
\newcommand{\prefixof}{\leqslant}
\newcommand{\suffixof}{\geqslant}
\newcommand\defname[1]{{\bf\em #1}\index{#1}}

\newcommand{\theroot}{\circledast} % the root of the computation tree

% misc
\newcommand\assignar\leftarrow

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]

\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]
\newtheorem{property}{Property}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{algorithm}{Algorithm}[section]

% order-decomposition of a 1-stack
\newcommand\orddec\overline


% ABBREVIATIONS
\def\ie{{\it i.e.}\ }
\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}

% set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\inter{\cap}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\prefset{\textsf{Pref}}
\newcommand{\relimg}[1]{{(\!| #1 |\!)}}
\newcommand\nat{\mathbb{N}}


% Note to myself
\newcommand\notetoself[1]{
\bigskip \noindent \fbox{
\begin{tabular}{cl}
\textdbend &
\begin{minipage}{0.80\textwidth}
#1
\end{minipage}
\end{tabular}
} }


\author{William Blum}
\title{Encoding of a safe order-$n$ recursion scheme into a $n$-PDA}

\begin{document}
\maketitle
\begin{abstract}
In \cite{hague-sto07}, Hague, Murawski, Ong and Serre introduced
higher-order collapsible pushdown automata (CPDA) and showed their
equivalence with higher-order recursion scheme. They proposed an
algorithm that transforms a given order-$n$ recursive  scheme G to
an equivalent order-$n$ CPDA. Here we show that if the recursion
scheme is safe then the generated automaton can in fact be simulated by an order
$n$ (non-collapsible) push-down automaton (PDA). The proof does not make
use of the type-homogeneity constraint. This contrasts with the original proof
of equi-expressivity (in term of generated trees) of PDAs and safe recursion schemes \cite{KNU02}.
\end{abstract}


\section{Preliminaries}

\subsection{Notations}

We fix a {\bf safe} higher-order recursion scheme $G$ of order $n$. Let $Gr(G)$ be the computation graph of $G$.
We consider the $n$-CPDA $CPDA(G)$ as defined in \cite[Definition 5.2]{hague-sto07}.
Recall that the stack-alphabet $\Gamma$ is defined as the set of nodes of the computation graph.
An element of the stack is written $a^{(j,k)}$ where $a\in \Gamma$ and the exponent $(j,k)$
encodes the pointer associated to the stack symbol. We observe that $CPDA(G)$ is such that the link associated to a lambda node $\lambda \overline{\xi}$ is always of the form $(n-\ord{\lambda \overline{\xi}}+1, k)$, therefore the first component of the link is always recoverable from the node itself. For this reason we omit it when representing stack symbols {\it i.e.} we write $\lambda \overline{\xi}^{k}$ to mean $\lambda \overline{\xi}^{(n-\ord{\lambda \overline{\xi}}+1,k)}$.


We call \defname{configuration} any order-$n$ stack where $n$ is the order
of $CPDA(G)$ \ie the order of the recursion scheme $G$.




\subsection{Incremental order-decomposition}

Let $s$ be a 1-stack. It can then be written as
$$ s = u_{r+1} \cdot \lambda \overline{\eta}_r^{k_r} \cdot u_r \cdot
\ldots \cdot \lambda \overline{\eta}_1^{k_1} \cdot  u_1 $$
where
\begin{compactitem}
\item  $\lambda \overline{\eta}_1^{k_1}$ is the
last $\lambda$-node in $s$ with order strictly positive;

\item for $1 < l \leq r$, $\lambda
\overline{\eta}_l^{k_l}$ is the last $\lambda$-node in $s_{\prefixof
\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$ with order strictly
greater than $\ord{\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$,

\item  $r$ is defined as the smallest number such that
$s_{\prefixof \lambda \overline{\eta}_{r}^{k_{r}}}$ does not contain
any lambda-node of order strictly greater than $\lambda
\overline{\eta}_{r}^{k_{r}}$.
\end{compactitem}

\noindent In particular:
\begin{compactitem}
\item for $1 \leq k \leq r$, all the lambda-nodes occurring in $u_l$ have order
strictly smaller than $\ord{\lambda \overline{\eta}_l}$;
\item for $1\leq l<l'\leq r$ we have $\ord{\lambda \overline{\eta}_l^{k_l}}
< \ord{\lambda \overline{\eta}_{l'}^{k_{l'}}}$;
\item $r=0$ if and only if all the lambda node in $s$ have order $0$ \ie if they are dummy lambda nodes.
\end{compactitem}
\smallskip

We call \defname{incremental order-decomposition} (or just
order-decomposition) of $s$ and we write $\orddec{s}$ to denote the
subsequence $\lambda
\overline{\eta}_r^{k_r} \ldots \lambda\overline{\eta}_1^{k_1}$ of $s$ consisting of the lambda-nodes $\lambda
\overline{\eta}_l^{k_l}$ defined above. For $1\leq l \leq r$, $l$ is called the \defname{incremental index} of the lambda-node $\lambda \overline{\eta}_l^{k_l}$ in $\orddec{s}$.
 Note that this sequence is uniquely determined.

Convention: In the original definition, the operation $top_i$ that returns the top $(i-1)$-stack of a higher-order stack, removes any dangling pointer resulting from the operation. Here, we suppose that $top_i$ is defined in such a way that all pointers are preserved. From an implementation viewpoint, since links are encoded as pairs of integers, this means that $top_i$ just returns an unmodified copy of the top $(i-1)$-stack. This convention allows us to
extend the definition of order-decomposition to higher-level stacks as follows:
\begin{definition}
The incremental order-decomposition
of a higher-order stack $s$ is defined as the incremental
order-decomposition of $top_2~s$ \ie $\orddec{s} = \orddec{top_2~s}$.
\end{definition}


\begin{lemma}
\label{lem:push1pop1_orderdecompo} Let $s$ be a higher-order stack
with order-decomposition $\orddec{s} = \langle \lambda
\overline{\eta}_r^{k_r}, \ldots, \lambda \overline{\eta}_1^{k_1}
\rangle$. Then
\begin{enumerate}[i.]
\item For all lambda node $a \in \Gamma$ and link $(j,k)$ we have
 $$ \orddec{push_1 a^{(j,k)}~s} = \left\{
                                       \begin{array}{ll}
                                        \langle a^k \rangle, &  \hbox{if $\ord{a} \geq \ord{\lambda \overline{\eta}_r^{k_r}}$}; \\
                                         \langle \lambda \overline{\eta}_r^{k_r}, \ldots, \lambda
\overline{\eta}_i^{k_i}, a^k \rangle, & \hbox{otherwise, where $i = \min \{ i \ | \ \ord{a} <
\ord{\lambda \overline{\eta}_i^{k_i}} \}$.}
                                       \end{array}
                                     \right.$$

\item For all non-lambda node $a \in \Gamma$ and link $(j,k)$ we have
$$ \orddec{push_1 a^{(j,k)}~s} = \orddec{s} \ .$$

\item If $top_1 s$ is not a lambda-node then
$$ \orddec{pop_1~s} = \orddec{s} \ .$$
\end{enumerate}
\end{lemma}
\begin{proof}
  Trivial from the definition of  $\orddec{s}$.
\end{proof}


We use the notion of reachable configuration
with respect to the $\rightarrow$-step relation introduced in the original paper.\footnote{Recall that $c\rightarrow c'$
just if $c' = \delta(top_1 c)(c)$ where $\delta$ is the transition
function defined in \cite[Figure 2]{hague-sto07}.} Thus a configuration of is reachable if it can be attained starting from the initial configuration ($push_1 \theroot \bot_n$) by performing one or more application of the steps (A), (S), (L), $(V_1)$, $(V_0)$ from the algorithm defining $CPDA(G)$.
In particular, the intermediate configurations visited by the internal transitions of a step are not considered reachable.

\begin{lemma}[Incremental binders are in the order-decomposition]
\label{lem:binder_in_ordecompos} Let $c$ be a reachable
configuration of $CPDA(G)$ such that $top_1\
c$ is a variable $x$ of order $l\geq 0$. Then
\begin{enumerate}[i.]
\item $\orddec{c}$ contains at least a node with order strictly
greater than $l$;
\item The last lambda node in $\orddec{c}$ verifying the first condition is precisely $x$'s binder.
\end{enumerate}
\end{lemma}
\begin{proof}
\begin{enumerate}[i.]
\item By Corollary 8 from \cite{hague-sto07}, the top $1$-stack of a configuration contains the P-view of some
    traversal whose last visited node is the $top_1$ symbol, and
    by Proposition 6 from \cite{OngLics2006}, the P-view of a
    traversal is exactly the path (in the unfolding of) the
    computation graph from the last visited node to
    the root. Hence the binder of $x$, whose order
    is strictly greater than $\ord{x}$, occurs in the top $1$-stack.
    Consequently $\orddec{c}$ must contain at least one node of order strictly greater than $l$.

\item Since the recursion scheme is safe, $x$ is
 incrementally bound (see \cite{blumong:safelambdacalculus})
 which means that its binder is precisely the first $\lambda$-node in the
 path to the root in the computation tree with order strictly
 greater than $x$.
\end{enumerate}
\end{proof}

\subsection{Safe higher-order stack}
\subsubsection{Definition}

\begin{definition}[Safe higher-order stack]
\label{dfn:safestack} Let $s$ be an order-$j$ stack for $j\geq1$ and $r
= |\orddec{s}|$.

We say that $s$ is \defname{safe} iif
    \begin{enumerate}[1.]
    \item $\orddec{s} = \langle \lambda \overline\eta_r^1, \ldots ,
    \lambda \overline{\eta}_1^1 \rangle$ \ie the $k$-components in $\orddec{s}$ are all equal to $1$;
    \item for all $1 \leq q \leq r$ such that $n-\ord{\lambda \overline\eta_q}+1 \leq \ord{s}$,
    $collapse~s_{\prefixof \lambda\overline\eta_q}$ is safe.
    \end{enumerate}
        
We say that $s$ is \defname{$q$-safe} if and only if the lambda node 
$\lambda\overline\eta$ of $\orddec{s}$ with incremental index $q$ verifies
    $collapse~s_{\prefixof \lambda\overline\eta}$ is safe.
\end{definition}

Equivalently, this definition can be reformulated inductively as follows:
an order-$1$ stack $s$ is safe if and only if $\orddec{s} = \langle \lambda \overline{\eta}_r^1, \ldots , \lambda \overline{\eta}_1^1 \rangle$;
a higher-order stack $s$ is safe iff $top_2~s$ is safe and
for any lambda-node $\lambda\overline\eta \in \orddec{s}$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$,
    $collapse~s_{\prefixof\lambda\overline\eta}$ is safe.


\begin{lemma}
\label{lem:safecollapsesimulation} 
If $s$ is safe, then for any lambda node $\lambda\overline\eta$ in $\orddec{s}$ we have:
$$collapse~s_{\prefixof\lambda\overline\eta} = pop_{n-\ord{\lambda\overline\eta}+1} ~s_{\prefixof\lambda\overline\eta} \ . $$
\end{lemma}

\begin{proof}
By definition of the $collapse$ operation, for any stack $s$ if the link attached to $top_1~s$ is $(j,k)$ then $collapse~s = pop_j^k~s$. Here since $s$ is safe, the link attached to the node $\lambda\overline\eta$ is of the form
$(n-\ord{\lambda\overline\eta}+1,1)$.
\end{proof}


\subsubsection{Stack operations preserving stack safety}
\begin{lemma}
\label{lem:push1pop1_preserves_safety} Let $s$ be a safe higher-order
stack. Then:
\begin{enumerate}
  \item If $top_1\ s$ is not a lambda-node then $pop\ s$ is safe;
  \item for any non-lambda node symbol $a$, $1 \leq j \leq n$, $k \geq 1$, $push_1\ a^{(j,k)}\ s$ is safe;
  \item for any lambda-node symbol $a$, $push_1\ a^{(n-\ord{a}+1,1)}\ s$ is safe.
\end{enumerate}
\end{lemma}
\begin{proof}
This is a direct consequence of Lemma
\ref{lem:push1pop1_orderdecompo}.
\end{proof}


\begin{lemma}
\label{lem:top_qsafe} If $s$ is safe then $top_{\ord{s}}~s$ is safe.
\end{lemma}


Let $s$ be a higher-order stack. We define $s^{\langle j \rangle}$ as the operation that replaces
every link occurring in $s$ of the form $(j,k)$ by $(j,k+1)$. Formally,
\begin{align*}
{a^{(j,k)}}^{\langle j \rangle} &= a^{(j,k)}   \\
{a^{(j,k)}}^{\langle j' \rangle} &= a^{(j,k+1)} &   \mbox{when $j\neq j'$,}\\
[s_1 \ldots s_p]^{\langle j \rangle} &= [s_1^{\langle j \rangle} \ldots s_p^{\langle j \rangle}] \ .
\end{align*}

\begin{lemma}
\label{lem:incrk_qsafe}
Let $n>l\geq 0$. Let $s$ be a stack of level $1\leq \ord{s} <n$.
 Let $b$ be the incremental index of the last lambda node in $\orddec{s}$
 with order $>l$.
If $s$ is safe then $s^{\langle n-l+1 \rangle}$ is $b$-safe.
\end{lemma}
\proof Take a safe stack of order $<n$.
 We first show the result for the case $\ord{s} = 1$:
Since $s$ is safe we have
$\orddec{s} = \langle \lambda \overline{\eta}_r^1
, \ldots, \lambda \overline{\eta}_1^1   \rangle$.
By definition, the operation $s^{\langle n-l+1 \rangle}$ updates the pointers in $s$  as follows:
the $k$ component of each link is increased by one if the order of
the stack symbol is $l$ and is kept unchanged otherwise.
Hence we have:
\begin{equation*}
\orddec{s^{\langle n-l+1 \rangle}} = \langle
\lambda \overline{\eta}_r^1, \ldots,  \lambda \overline{\eta}_{q}^1, \lambda \overline{\eta}_{q-1}^{k_{q-1}}, \ldots,
 \lambda \overline{\eta}_1^{k_1} \rangle
\end{equation*}
for some $k_{q-1}, \ldots , k_1 \leq 2$, where $q$ is the incremental index of the last lambda-node in $\orddec{s}$ with order $>l$. By assumption $b$ is precisely equal to $b$ therefore $s^{\langle n-l+1 \rangle}$ is $b$-safe.

Suppose that $1<\ord{s}<n$.
By definition of stack-safety (Def.~\ref{dfn:safestack}), to show that $s^{\langle n-l+1 \rangle}$ is $b$-safe it suffices to prove that
\begin{enumerate}
\item $top_2~s^{\langle n-l+1 \rangle}$ is $b$-safe,
\item for all $b\leq q \leq r$ such that
$n-\ord{\lambda \overline{\eta}_{q}} +1 \leq \ord{s^{\langle n-l+1 \rangle}}$, $collapse~s_{\prefixof \lambda \overline{\eta}_{q}}$ is safe.
\end{enumerate}

First condition: Clearly we have $top_2~s^{\langle n-l+1 \rangle} = (top_2~s)^{\langle n-l+1 \rangle}$. Since $s$ is safe, so is $top_2~s$. We have proven the result for $1$-stacks thus we can apply it to $top_2~s$ which shows that $(top_2~s)^{\langle n-l+1 \rangle}$ is $b$-safe.
 
Second condition: The only symbols that are updated in $s$ by the operation $s \mapsto s^{\langle n-l+1 \rangle}$ are those occurring in the top order-$1$ stack $top_2~s$. Thus since the first $r-b+1$ lambda-nodes in $\orddec{s^{\langle n-l+1 \rangle}}$ and $\orddec{s}$ coincide, this implies that $collapse(s^{\langle n-l+1 \rangle}_{\prefixof\lambda\overline\eta_q}) = collapse(s_{\prefixof\lambda\overline\eta_q})$ for all $b \leq q \leq r$.
Hence the safety of $s$ implies the safety of $s^{\langle n-l+1 \rangle}_{\prefixof\lambda\overline\eta_b}$ \ie the $b$-safety of $s^{\langle n-l+1 \rangle}$.
\qed
\smallskip

\begin{lemma}
\label{lem:cons_qsafety} Let $s$ be a higher-order stack of level $\geq 2$. If
\begin{enumerate}[1.]
\item $pop_{\ord{s}}~s$ is safe;
\item and $top_{\ord{s}}~s$ (of order $(\ord{s}-1)$) is safe,
\end{enumerate}
then $s$ is safe.
\end{lemma}
\proof
Let $s = [s_1 \ldots s_l~s_{l+1}]$ for some $l\geq0$.
We proceed by induction on  $top_{\ord{s}}~s=s_{l+1}$.
The base case $s_{l+1} = \bot_{\ord{s}-1}$ is trivial.
Suppose that $s_{l+1}$ is not the empty stack. We show that $s$ is safe using the inductive definition of stack-safety \ie we show that $top_2~s$ is safe and that for all lambda-node $\lambda \overline{\eta} \in \orddec{s}$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$, $collapse~s_{\prefixof \lambda \overline{\eta}}$ is safe:
\begin{itemize}
\item First condition: If $\ord{s}=2$ then $top_2~s = top_{\ord s}~s$ which is safe by the second assumption. Otherwise $\ord{s}>2$ and since $top_{\ord{s}} s$ is safe, so is $top_2(top_{\ord{s}} s)$. By definition of $top_2$ we have $top_2~s = top_2(top_{\ord{s}} s)$ hence $top_2~s$ is safe.

\item Second condition: Let $\lambda \overline{\eta}$ be a lambda-node in $\orddec{s} = \orddec{s_{l+1}}$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$.
Since $top_2(s)$ is safe, by Lemma \ref{lem:safecollapsesimulation} we have
$collapse~s_{\prefixof \lambda \overline{\eta}} = pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof \lambda \overline{\eta}}$.

If $n-\ord{\lambda \overline{\eta}}+1 = \ord{s}$ then
$pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof \lambda \overline{\eta}} = pop_{\ord{s}}~s_{\prefixof\lambda\overline\eta} = pop_{\ord{s}}~s$ which is safe by the first assumption.

Otherwise $n-\ord{\lambda \overline{\eta}}+1 < \ord{s}$ and we have:
\begin{align*}
  collapse~s_{\prefixof\lambda\overline\eta}
      &= pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof\lambda\overline\eta} 
      & \mbox{by Lemma \ref{lem:safecollapsesimulation}, since $s_{\prefixof\lambda\overline\eta}$ is safe} \\
  &= [ s_1 \ldots s_l\ (pop_{n-\ord{\lambda\overline\eta}+1}~ {s_{l+1}}_{\prefixof\lambda\overline\eta}) ]
   & \mbox{$n-\ord{\lambda \overline{\eta}}+1<\ord{s}$}  \\
  &= [s_1 \ldots s_p~collapse({s_{l+1}}_{\prefixof\lambda\overline\eta}) ]
  & \mbox{by Lemma \ref{lem:safecollapsesimulation}, since $s_{l+1}$ is safe}
\end{align*}

By the second assumption, $s_{l+1} = top_{\ord{s}}~s$ is safe therefore by definition
of safety so is $collapse~{s_{l+1}}_{\prefixof\lambda\overline\eta}$, thus
since $|collapse~{s_{l+1}}_{\prefixof\lambda\overline\eta}| < |s_{l+1}|$ we can use the induction hypothesis which shows that $[s_1 \ldots s_p~collapse({s_{l+1}}_{\prefixof\lambda\overline\eta}) ]$ is safe.
\qed
\end{itemize}



\begin{lemma}
\label{lem:pushj_safe_implies_b-safe} Let $n>l\geq 0$ and $s$ be a higher-order stack
of level $2 \leq n-l+1 \leq \ord{s} \leq n$. Let $b$ be the incremental index of the last lambda node in $\orddec{s}$ with order $>l$. Then $push_{n-l+1}\ s$ is $b$-safe.\footnote{We reproduce here the definition of the
CPDA operation $push_j$ from \cite{hague-sto07}:
$$ push_j \underbrace{[ s_1 \ldots s_{l+1} ]}_{s} =
\left\{
  \begin{array}{ll}
\    [s_1\ \ldots\ s_{l+1}\ s_{l+1}^{\langle j \rangle}]  &\hbox{if $j = \ord{s}$;}\\
\    [s_1\ \ldots\ s_{l+1}\ push_j\ s_{l+1}]  &\hbox{if $j<\ord{s}$.}
 \end{array}
\right.
$$}
\end{lemma}
\begin{proof}
Let $s=[s_1 \ldots s_{c+1}]$ be any safe higher-order stack of order. We show that $push_{n-l+1}~s$ is $b$-safe by finite induction on the order of $s$.
    \begin{compactitem}
      \item Base case: $\ord{s} = n-l+1 $. We have
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$.

    Since $s$ is safe, by Lemma \ref{lem:top_qsafe} so is $s_{c+1}$
    which in turn implies that $s_{c+1}^{\langle n-l+1\rangle}$ is
    $b$-safe by Lemma \ref{lem:incrk_qsafe}. Therefore by Lemma
    \ref{lem:cons_qsafety},  $[ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$ is $b$-safe.

      \item Step case: $\ord{s} > n-l+1$. We have
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} push_{n-l+1}~s_{c+1}]$.

    $s_{c+1}$ is safe by Lemma \ref{lem:top_qsafe} thus by the
    induction hypothesis $push_{n-l+1}~s_{c+1}$ is $b$-safe and therefore by Lemma \ref{lem:cons_qsafety} so
    is $[ s_1 \ldots s_{c+1} push_{n-l+1}~s_{c+1}]$.
    \end{compactitem}
\end{proof}





\section{Simulation}

We claim that provided that the input recursion scheme is safe, the
uses of the $collapse$ operation in $CPDA(G)$ can all be replaced by the operation $pop_{n-\ord{top_1(s)}+1}$. 

\section{Proof of correctness}

\begin{proposition}
All the reachable configurations of CPDA(G) are safe.
\end{proposition}
\begin{proof}
If $n =\ord{c} =1$ then the result holds trivially since CPDA(G) does not contain
any transition of the form $push_j$ for $j>1$ and therefore all the links associated to symbols in a configuration have a $k$-component equals to $1$.

Suppose that $n\geq 2$. We prove the result by induction on the number of
$\rightarrow$-steps. The initial configuration is trivially safe.
Suppse that $c$ is a safe reachable configuration and that
$c'=\delta(u)(c)$ where $u = top_1\ c$.
We show that $c'$ is safe by case analysis on $u$:
\begin{itemize}
\item[Case (A)] Pushing @ on the top $1$-stack preserves safety (Lemma
\ref{lem:push1pop1_preserves_safety}), therefore $c'$ is safe.

\item Case (S)
We have $c' = push_1 a^{(n-\ord{a}+1,1)} c$ where $a$ is a
lambda-node, therefore by Lemma \ref{lem:push1pop1_preserves_safety},
$c'$ is safe.

\item Case (L) Again, Lemma \ref{lem:push1pop1_preserves_safety}
shows that (i) holds and (ii) trivially holds.

\item Case ($V_1$) Suppose $u$ is labelled by a variable $x$ of order $l\geq 1$.

Since $c$ is safe we have $\orddec{c} = \langle \lambda
\overline{\eta}_r^1 , \ldots, \lambda \overline{\eta}_1^1
\rangle$.
Since the recursion-scheme $G$ is safe, by Lemma \ref{lem:binder_in_ordecompos}, $x$'s binder is precisely the
last node in $\orddec{c}$ with order strictly greater than $l$.
Hence by Lemma \ref{lem:pushj_safe_implies_b-safe}
we have that $push_{n-l+1}\ c$ is $b$-safe where $b$ is the
incremental index of $x$'s binder in $\orddec{c}$.

Consequently by definition of $b$-safety we have that
$t = collapse \left( (push_{n-l+1}~ c)_{\prefixof \lambda
\overline{\eta}_{b}} \right) = (push_{n-l+1};pop_1^p;collapse)
~c$ is safe. Hence by
Lemma \ref{lem:push1pop1_preserves_safety}, $c' = push_1 E_i(top_1)^{(n-l+1,1)}\ t$ is also safe.

\item ($V_0$) This case is treated identically to ($V_1$).
\end{itemize}
\end{proof}

\begin{corollary}
In CPDA(G), the $collapse$ operation is executed only on safe configurations.
\end{corollary}
\begin{proof}
In CPDA(G), the only occurrences of the collapse operation are in the steps ($V_1$) and ($V_0$) and are of the form:
$$ collapse(pop_1^p(push_{n-l+1}~c))$$
for some reachable configuration $c$, where $top_1(u)$ is a variable of order $l$ and of span $p$. In the proof of the previous proposition, we have shown that
$push_{n-l+1}~c$ is $b$-safe where $b$ is the incremental index of $x$'s binder in $\orddec{c}$. After performing $pop_1^p$, the top stack symbol contains $x$'s
binder which is precisely the lambda-node with incremental index $b$. Therefore $pop^p_1(push_{n-l+1}~c)$ is safe.
\end{proof}

Together with Lemma \ref{lem:safecollapsesimulation}, this shows that the simulation is sound.



\section{Remark}
It is possible to redefine $CPDA(G)$ from
\cite{hague-sto07} in a more compact way by merging the two subcases in
$(V_1)$ and $(V_0)$. This is done as follows: In case (A), when
pushing the prime child of an application node $@$ on the stack, we
associate a link to it that points to the preceding stack symbol in
the top $1$-stack \ie the $@$-node itself.
 This modification permits us to avoid the consideration on $j$ (the child-index of $u$'s binder) in the
 cases ($V_0$) and ($V_1$). The sequences of instruction $pop_1^{p+1}$ can now be replaced by
 $pop_1^p ; collapse$. The resulting CPDA is denoted by $CPDA'(G)$ and is described in
Figure \ref{fig:cpdaprime}.
\begin{figure}[htbp]
\begin{center}
\makebox{
\begin{shadowbox}[10cm]
If $u$'s label is not a variables, the action is just a $push_1^v$, where $v$ is an appropriate child of the node $u$. Precisely:
\begin{itemize}
\item $(A)$ If the label is an @ then $\delta(u) = push_1^{E_0(u),1}$.
\item $(S)$ \ldots
\item $(L)$ \ldots
\end{itemize}
Suppose $u$ is a variable which is the $i$-parameter of
its binder and let $p$ be the span of $u$.
\begin{itemize}
\item $(V_1)$ If the variable has order $l\geq 1$, then
$$\delta(u) = push_{n-l+1} ; pop_1^p ; collapse;push_1 E_i(top_1)^{(n-l+1,1)}$$
\item $(V_0)$ If the variable is of ground type then
$$\delta(u) = pop_1^p ; collapse;push_1 E_i(top_1)$$
\end{itemize}
\caption{CPDA'(G): a compact version of CPDA(G).}
\label{fig:cpdaprime}
\end{shadowbox}
}
\end{center}
\end{figure}
Contrary to $CPDA(G)$, in a configuration of this CPDA the link associated to a lambda node $\lambda\overline\eta$ is not necessarily of the form
$(n-\ord{\lambda\overline\eta}+1,k)$. Instead the first component of the link pair $(j,k)$ associated to a lambda node is defined as follows:
$j = 1$ if $\lambda\overline\eta$ is a prime node and $j=n-\ord{\lambda\overline\eta}+1$ otherwise. Therefore we can simulate the collapse operation 
using transitions performing $pop_1$ if $top_1~s$ is prime and $pop_{n-\ord{top_1(s)}+1}$ otherwise.
\clearpage

\bibliographystyle{abbrv}
\bibliography{../bib/dphil-all}

\end{document}
