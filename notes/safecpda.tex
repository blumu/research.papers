%Daemon> ini=pdflatex
%Daemon> filter=err+warn
%Daemon> custom_args="-synctex=1"
\documentclass[a4paper,draft]{article}
\usepackage{gamesem}
\usepackage{todonotes}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[defblank]{paralist}
\usepackage{shadowbox}
%\usepackage{a4wide}
\usepackage{manfnt}
%\usepackage{pdfsync}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]

\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]
\newtheorem{property}{Property}[section]
\newtheorem{convention}{Convention}[section]


\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{algorithm}{Algorithm}[section]

% order-decomposition of a 1-stack
\newcommand\orddec{{\sf orddec}}
\newcommand\sig{{\sf sig}}

\newcommand\Nodes{N}% set of nodes
\newcommand\INodes{IN}% set of inner nodes
\newcommand\LNodes{L}% set of leaf nodes

\author{William Blum}
\title{Encoding of a safe order-$n$ recursion scheme into a $n$-PDA}

\begin{document}
\maketitle
\begin{abstract}
Hague, Murawski, Ong and Serre \cite{hmos-lics08} introduced
higher-order collapsible pushdown automata (CPDA) and showed that they are
equivalent to higher-order recursion scheme. They proposed an
algorithm that transforms a given order-$n$ recursive scheme G to
an equivalent (in the sense that they generate the same tree) order-$n$ CPDA. Here we show that if the recursion
scheme is safe then the generated automaton can in fact be simulated by an order
$n$ (non-collapsible) push-down automaton (PDA). The proof does not make
use of the type-homogeneity constraint. This contrasts with the original proof
of equi-expressivity of PDAs and safe recursion schemes \cite{KNU02}.
\end{abstract}

\todo{A proof attempt was presented in a previous version of this note. Broadbent has then
obtained a working proof based on the same idea but using a different notion of stack-safety \cite{Broadbent2009}.
This note fixes the hole in my original proof by introducing yet another definition of stack safety inspired
by Broadbent's one.}



\section{The HORS to HOCPDA encoding}

We fix a higher-order recursion scheme $G$ of order $n$.
We consider the $n$-CPDA $CPDA(G)$ constructed from $G$ as defined in Hague et al.'s paper \cite[Definition 5.2]{hague-collaps-full}.
Recall that the stack-alphabet $\Gamma$ is defined as the set of nodes of the computation graph $Gr(G)$ of $G$.

The automaton $CPDA(G)$ proceeds by computing the set of traversals of the computation tree of $G$. One can easily transform $CPDA(G)$ into an automaton that ``prints out'' the traversal that is being computed. This can be done by changing the behaviour of the $push_1$ operation to make it print out the input element before pushing it on the stack. The justification pointers can then be recovered inductively using the node labels: To recover the justifier of a variable node, we just need to look for the only node-occurrence that binds it in the P-view at that point (which is computable by the induction hypothesis).
Prime lambda nodes always point to their immediate predecessor. For non-prime lambda nodes, the justifier is always the occurrence preceding the justifier of the variable node preceding the lambda node.

Since some of the transitions of the CPDA, such as $collapse$, are destructive, the current configruation stack
is not sufficient in itself to reconstruct the traversal that is being computed.
Nevertheless, two very useful pieces of information can be recovered from the configuration-stack: namely the O-view and the P-view of the traversal.

Let $c$ be a configuration. The \defname{long O-view},
\defname{O-view} and \defname{P-view} of the traversal that is currently computed by the configuration $c$, written respectively $\longoview{c}$, $\oview{c}$ and $\pview{c}$, can be recovered as follows:
\begin{compactitem}
\item Long O-view:
\begin{align*}
&  \longoview{s} = \\
 & \quad \left\{
  \begin{array}{ll}
      \epsilon & \mbox{if $top_1 s$ is undefined;} \\
      \longoview{pop_1 s} \cdot top_1 s & \parbox[t]{7cm}{if $top_1\,s \in \INodes_{\sf var}$, $top_1 s$ pointing to its immediate predecesor;} \\
      \longoview{pop_1 s} \cdot top_1 s & \mbox{if $top_1\,s \in \INodes_@$, $@$ having no pointer;} \\
      \longoview{collapse\,s} \cdot top_1 s & \parbox[t]{7cm}{if $top_1\,s \in \INodes_\lambda^{\sf prime}$, $top_1 s$ pointing to its immediate predecesor;} \\
      \longoview{collapse\,s} \cdot top_1 s & \parbox[t]{7cm}{if $top_1\,s \in \INodes_\lambda\setminus \INodes_\lambda^{\sf prime}$, $top_1 s$ pointing to $\ip(\jp(collapse\,s))$.}
    \end{array}
      \right. 
\end{align*}
\item The O-view is defined similarly to the long-O-view except that the calculation stops when an @-node is reached:
\begin{align*}
  \oview{s}  &=   top_1 s & \mbox{if $top_1 s \in \INodes_@$, $@$ having no pointer;}
\end{align*}
\item As shown in the original paper, the P-view $\pview{s}$ is given by $top_2\,c$.
\end{compactitem}
\bigskip

We call \defname{configuration} any order-$n$ stack where $n$ is the order
of $CPDA(G)$ (which is also the order of the recursion scheme $G$).

The initial configuration of $CPDA(G)$ is $c_0 = push_1 \lambda \bot_n$
where $\lambda$ refers to the root (dummy) lambda node of the computation graph.

\section{Safe HORS to HOPDA encoding}

We fix a {\bf safe} higher-order recursion scheme $G$ of order $n$.
By analysing the $CPDA(G)$, we show that it is possible to construct a higher-order PDA of order $n$ that is equivalent to $CPDA(G)$.


\subsection{Basic definitions}

\paragraph{Reachable configurations}
We use the notion of reachability with respect to the $\rightarrow$-step relation introduced in the original paper:
$c\rightarrow c'$ just if $c' = \delta(top_1 c)(c)$ where $\delta$ is the transition
function defined Hague et al.'s paper \cite[Figure 2]{hague-collaps-full}.
In other words, a configuration is \defname{$\rightarrow$-reachable} if it can be attained starting from the initial configuration $c_0$ by performing
one or more applications of the steps (A), (S), (L), $(V_1)$, $(V_0)$ from the algorithm defining $CPDA(G)$.
The intermediate configurations visited by the internal transitions within a step are therefore not $\rightarrow$-reachable.
A configuration is said to be \defname{reachable} if it is $\rightarrow$-reachable or if it
an intermediate configuration computed during a $\rightarrow$-step
(\ie, if it can be written $(op_1;\ldots;op_k)(c)$ where $c$ is $\rightarrow$-reachable and
$op_1, \ldots, op_k$ are the first $k$ instructions of some $\rightarrow$-step).

\paragraph{Link convention}
An element of the CPDA stack is written $a^{(j,k)}$ where $a\in \Gamma$ and the exponent $(j,k)$
encodes the pointer associated to the stack symbol. The value $j$ is called the order of the link, and $k$ is called the height of the link. We observe that when $CPDA(G)$ pushes
a lambda node $\lambda \overline{\xi}$ on the stack, the associated link is always of the form $(n-\ord{\lambda \overline{\xi}}+1, k)$, therefore the order component of the link is
recoverable from the node itself. Because the order component cannot be changed once the element is pushed onto the stack, the order component of the links associated to lambda nodes
in the configuration stack of $CPDA(G)$ will always be of the form given above.
Furthermore, the order-component of a link is of no use for non-lambda nodes since the collapse operation is only executed on stack whose top element is a lambda node.
From now on we will only work with stacks occurring as sub-stack of reachable configurations of $CPDA(G)$
therefore we will omit the order-component altogether when representing stack symbols: we write $\lambda \overline{\xi}^{k}$ to mean $\lambda \overline{\xi}^{(n-\ord{\lambda \overline{\xi}}+1,k)}$.


\todo{Add definition of stack prefix ``$s_{\prefixof m}$'' and ``$s_{<m}$'' \cite{hmos-lics08}.}


\begin{definition}
Let $s$ be a higher-order stack. We define $s^{\langle j \rangle}$ as the operation that replaces
every link occurring in $s$ of the form $(j,k)$ by $(j,k+1)$. Formally,
\begin{align*}
{a^{(j,k)}}^{\langle j \rangle} &= a^{(j,k+1)}   \\
{a^{(j,k)}}^{\langle j' \rangle} &= a^{(j,k)} &   \mbox{when $j\neq j'$,}\\
[s_1 \ldots s_p]^{\langle j \rangle} &= [s_1^{\langle j \rangle} \ldots s_p^{\langle j \rangle}] \ .
\end{align*}
\end{definition}
This operation clearly commutes with prefixing. We will therefore write $s^{\langle j\rangle}_{\prefixof m}$ as an abbreviation for
$(s^{\langle j\rangle})_{\prefixof m} = (s_{\prefixof m})^{\langle j\rangle}$,
for all stack $s$ and stack-symbol $m$ occurring in $s$.


We reproduce here the definition of the CPDA operation $push_j$ \cite{hmos-lics08}:
$$ push_j \underbrace{[ s_1 \ldots s_{l+1} ]}_{s} =
\left\{
  \begin{array}{ll}
\    [s_1\ \ldots\ s_{l+1}\ s_{l+1}^{\langle j \rangle}]  &\hbox{if $j = \ord{s}$;}\\
\    [s_1\ \ldots\ s_{l+1}\ push_j\ s_{l+1}]  &\hbox{if $j<\ord{s}$.}
 \end{array}
\right.
$$


\begin{convention}[Top stack convention]
\label{conv:top_preserve_links}
In the original definition, the operation $top_i$, that returns the top $(i-1)$-stack of a higher-order stack,
 removes any dangling pointer resulting from the operation. Here, we suppose that $top_i$ is defined in such a way that all pointers are preserved. From an implementation viewpoint, since links are encoded as pairs of integers, this means that $top_i$ just returns an unmodified copy of the top $(i-1)$-stack.
\end{convention}

\subsection{Succinct definition of CPDA(G)}
It is possible to redefine the collapsible pushdown automaton $CPDA(G)$ from Hague et al.
\cite{hmos-lics08} in a more compact way by merging the two subcases in
$(V_1)$ and $(V_0)$. This is done as follows: In case (A), when
pushing the prime child of an application node $@$ on the stack, we
associate a link to it that points to the preceding stack symbol in
the top $1$-stack (\ie, the $@$-node itself).
 This modification avoids the case analysis on the value of $j$---the child-index of $u$'s binder---in the
 cases ($V_0$) and ($V_1$). The sequences of instruction $pop_1^{p+1}$ can now be replaced by
 $pop_1^p ; collapse$. The resulting CPDA is denoted by $CPDA'(G)$ and is described in
Figure \ref{fig:cpdaprime} where the following two notations are used:
\begin{itemize}
\item ``$push_1^{a,j}$'' stands for the operation $push_1\,a^{(j,1)}$;
\item ``$push_1^a$'' stands for the operation $push_1\,a^{(j,k)}$ where the components $j$ and $k$ are undetermined.
\end{itemize}
The automaton is well-defined in the sense that no collapse can occur at an element whose link is undetermined.
\begin{figure}
\begin{center}
\makebox{
\begin{shadowbox}[10cm]
If $u$'s label is not a variables, the action is just a $push_1^v$, where $v$ is an appropriate child of the node $u$. Precisely:
\begin{itemize}
\item $(A)$ If the label is an @ then $\delta(u) = push_1^{E_0(u),{\bf 1}}$.
\item $(S)$ If the label is a $\Sigma$-symbol $f$ then $\delta(u) = push_1^{E_i(u)}$, where $1 \leq i \leq ar(f)$ is the direction requested by the Environment, or Opponent.

\item $(L)$ If the label is a lambda then $\delta(u) = push_1^{E_1(u)}$.
\end{itemize}
Suppose $u$ is a variable which is the $i$-parameter of
its binder and let $p$ be the span of $u$.
\begin{itemize}
\item $(V_1)$ If the variable has order $l\geq 1$, then
$$\delta(u) = push_{n-l+1} ; pop_1^p ; collapse;push_1^{E_i(top_1), n-l+1}$$
\item $(V_0)$ If the variable is of ground type then
$$\delta(u) = pop_1^p ; collapse;push_1^{E_i(top_1)}$$
\end{itemize}
\caption{CPDA'(G), a compact version of CPDA(G).}
\label{fig:cpdaprime}
\end{shadowbox}
}
\end{center}
\end{figure}

\begin{remark}
\label{rem:linkorder_cpdaprime}
Note that contrary to $CPDA(G)$ in this automaton the link associated to a lambda node $\lambda\overline\eta$ is not necessarily of the form
$(n-\ord{\lambda\overline\eta}+1,k)$. Instead the order of the link associated to a lambda node is
$1$ if $\lambda\overline\eta$ is a prime node, and $n-\ord{\lambda\overline\eta}+1$ otherwise.
\end{remark}


\subsection{Incremental order-decomposition}
\paragraph{Observation}
Let $s$ be a 1-stack. For any $l\in \nat$, $s$ can then be written
$$ s = u_{r+1} \cdot \lambda \overline{\eta}_r^{k_r} \cdot u_r \cdot
\ldots \cdot \lambda \overline{\eta}_1^{k_1} \cdot  u_1 $$
where
\begin{itemize}
\item  $\lambda \overline{\eta}_1^{k_1}$ is the
last $\lambda$-node in $s$ with order strictly greater than $l$;

\item for $1 < l \leq r$, $\lambda
\overline{\eta}_l^{k_l}$ is the last $\lambda$-node in $s_{\prefixof
\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$ with order strictly
greater than $\ord{\lambda \overline{\eta}_{l-1}^{k_{l-1}}}$,

\item  $r$ is defined as the smallest number such that
$s_{\prefixof \lambda \overline{\eta}_{r}^{k_{r}}}$ does not contain
any lambda node of order strictly greater than $\lambda
\overline{\eta}_{r}^{k_{r}}$.
\end{itemize}

\noindent In other words:
\begin{itemize}
\item for $1 \leq k \leq r$, all the lambda nodes occurring in $u_l$ have order
strictly smaller than $\ord{\lambda \overline{\eta}_l}$;
\item for $1\leq l<l'\leq r$ we have $\ord{\lambda \overline{\eta}_l^{k_l}}
< \ord{\lambda \overline{\eta}_{l'}^{k_{l'}}}$;
\item $r=0$ if and only if all the lambda node in $s$ have order $\geq l$.
\end{itemize}

The subsequence $\lambda \overline{\eta}_r^{k_r} \ldots \lambda\overline{\eta}_1^{k_1}$ of $s$ consisting of the lambda nodes $\lambda
\overline{\eta}_l^{k_l}$ defined above is called the \defname{incremental order-decomposition of the $1$-stack} $s$ {\bf with respect to} $l\in\nat$.
This sequence is uniquely determined for any given $l\in \nat$.

\smallskip

We now generalize this notion to higher-order stacks.
\begin{definition}
The \defname{incremental order-decomposition of a higher-order stack} $s$ {\bf with respect to $l\in \nat$} (or
order-decomposition for short), written $\orddec_l(s)$, is defined as the order-decomposition of the top order-$1$ stack (defined using convention \ref{conv:top_preserve_links}). Equivalently it can be defined as follows:
\begin{align*}
  \orddec_l(\epsilon) &= \epsilon \\
    \mbox{for } s\neq\epsilon\quad \orddec_l(s) &=     \orddec_{\ord{\lambda\overline{\eta}}}(s_{<\lambda\overline{\eta}}) \cdot \lambda\overline{\eta}^k \\
& \mbox{\quad where } \lambda\overline{\eta}^k \mbox{ is the last node in $top_2\,s$ with order $>l$\ .}
\end{align*}
The \defname{incremental order-decomposition} of $s$, written
$\orddec(s)$, is defined as:
$$
\orddec(s) = \orddec_0(s) \ .
$$
\end{definition}

It follows immediately from the definition that:
\begin{equation}
l<l' \implies \orddec_{l'}(s) \prefixof \orddec_{l}(s)
\label{eqn_safe_prefix}\end{equation}
where $\prefixof$ denotes the sequence-prefix ordering.


\begin{lemma}
\label{lem:push1pop1_orderdecompo} Let $s$ be a (possibly higher-order) stack
such that $top_1\,s \in \INodes_@ \union \INodes_{var}$ and $l\geq 0$.
\begin{enumerate}[(i)]
\item Suppose that $\orddec_l(s) = \langle \lambda
\overline{\eta}_r^{k_r}, \ldots, \lambda \overline{\eta}_1^{k_1}
\rangle$ then for any lambda node $a \in \Gamma$ and link $(j,k)$ we have
 \begin{align*} &\orddec_l(push_1 a^{(j,k)}~s) = \\
&                 \qquad \left\{
                                       \begin{array}{ll}
\orddec_l(s), &\hbox{if $\ord{a}\leq l$;} \\
                                        \langle a^k \rangle, &  \hbox{if $\ord{a} \geq \ord{\lambda \overline{\eta}_r}$}; \\
                                         \langle \lambda \overline{\eta}_r^{k_r}, \ldots, \lambda
\overline{\eta}_i^{k_i}, a^k \rangle, 
&                                        \mbox{otherwise,} \\
&                              i = \min \{ i \ \in \{1..r\}| \, \ord{a} <
\ord{\lambda \overline{\eta}_i} \}\ .
\\
                                       \end{array} 
                                     \right.
\end{align*}
\item For any non-lambda node $a \in \Gamma$ and link $(j,k)$ we have
$$ \orddec_l(push_1\,a^{(j,k)}\,s) = \orddec_l(s) \ .$$

\item If $top_1 s$ is not a lambda node then
$$ \orddec_l(pop_1\,s) = \orddec_l(s) \ .$$
\end{enumerate}
\end{lemma}
\begin{proof}
Follows immediately from the definition of  $\orddec_l(s)$.
\end{proof}



\begin{lemma}[Incremental binders are in the order-decomposition]
\label{lem:binder_in_ordecompos} Let $c$ be a $\rightarrow$-reachable
configuration of $CPDA(G)$ such that $top_1\,c$ is a variable $x$. Then
\begin{enumerate}[(i)]
\item $\orddec(c)$ contains at least a node with order strictly greater than $\ord(x)$;
\item the last lambda node in $\orddec(c)$ satisfying the first condition is precisely $x$'s binder.
\end{enumerate}
In other words, $x$'s binder is the last lambda node in $\orddec_{\ord x}(c)$.
\end{lemma}
\begin{proof}
\begin{enumerate}[(i)]
\item The top $1$-stack of a $\rightarrow$-reachable configuration contains the P-view of some traversal whose last visited node is the $top_1$ symbol \cite[Corollary 8]{hague-collaps-full}; and
    the P-view of a traversal is exactly the path (in the unfolding of) the
    computation graph from the last visited node to
    the root \cite[Proposition 6]{OngLics2006}. Hence the binder of $x$, whose order
    is strictly greater than $\ord{x}$, occurs in the top $1$-stack.
    Consequently $\orddec(c)$ must contain at least one node of order strictly greater than $l$.

\item Since the recursion scheme is safe, $x$ is
 incrementally bound \cite{blumong:safelambdacalculus}
 which means that its binder is precisely the first $\lambda$-node in the
 path to the root in the computation tree with order strictly
 greater than $x$. \qedhere
\end{enumerate}
\end{proof}

\subsection{Stack safety}

\begin{definition}[Safe stack]
\label{dfn:safestack} Let $s$ be an order-$j$ non-empty stack for $j\geq1$.

The stack $s$ is \defname{$l$-safe} iff
    \begin{enumerate}[1.]
    \item $\orddec_l(s) = \langle \lambda \overline\eta_r^1, \ldots ,
    \lambda \overline{\eta}_1^1 \rangle$ for some $r\geq 0$ \ie, the height component of the links in $\orddec_l(s)$ are all equal to $1$;

    \item for all $1 \leq q \leq r$ such that $n-\ord{\lambda \overline\eta_q}+1 \leq \ord{s}$:
    \begin{itemize}
    \item for $q = 1$ we have $collapse~s_{\prefixof \lambda\overline\eta_1}$ is $l$-safe;
    \item for $q>1$ we have $collapse~s_{\prefixof \lambda\overline\eta_q}$ is $\ord(\lambda \overline\eta_{q-1})$-safe.
    \end{itemize}
    \end{enumerate}

We say that $s$ is \defname{safe} if it is $0$-safe.
\end{definition}


Since $s$ is a stack, and not necessarily a configuration, it may have dangling pointers.
The condition $n-\ord{\lambda \overline\eta_q}+1 \leq \ord{s}$ in the definition ensures that
$\lambda\overline\eta_j$'s link is not dangling so that we can indeed perform a collapse at $\lambda\overline\eta_j$.

%\begin{lemma}[Equivalent formulation]
%The following formulations of safety are all equivalent:
%\begin{enumerate}
%\item
%Let $s$ be a non-empty stack with order-decomposition
%$\orddec(s)= \langle \lambda \overline\eta_r^{k_r}, \ldots ,
%    \lambda \overline{\eta}_1^{k_1} \rangle$.
%
%Then $s$ is safe iff
%\begin{compactitem}
%    \item if $n-\ord{\lambda \overline\eta_1}+1 \leq \ord{s}$ then
%    $collapse\, s_{\prefixof \lambda\overline\eta_1}$ is $l$-safe;
%    \item  if $r\geq 2$ then  $s_{\prefixof \lambda\overline\eta_2}$ is $\ord{\lambda\overline\eta_1}$-safe.
%\end{compactitem}
%
%\item
%An order-$1$ stack $s$ is safe if and only if $\orddec(s) = \langle \lambda \overline{\eta}_r^1, \ldots , \lambda \overline{\eta}_1^1 \rangle$ with $r\geq 1$;
%a higher-order stack $s$ is safe iff $top_2\,s$ is safe and
%for any lambda node $\lambda\overline\eta \in \orddec(s)$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$, $collapse\, s_{\prefixof\lambda\overline\eta}$ is $k$-safe where
%$k=l$ if $\lambda\overline\eta$ is the last node in the order decomposition
%otherwise $k$ is the order of the lambda node following
%$\lambda\overline\eta$ in the order decomposition.
%\end{enumerate}
%\end{lemma}

\begin{lemma}
\label{lem:stacksafety_immediate results}
Let $s$ be a stack such that $\orddec_l(s) = \langle \lambda \overline\eta_r^{k_r}, \ldots, \lambda \overline{\eta}_1^{k_1} \rangle$ and $l\geq 0$.
%\begin{enumerate}[(i)]
%\item
If $s$ is $l$-safe and $l \leq k \leq n$ then $s$ is $k$-safe.
%\item $s$ is $l$-safe iif $s_{\prefixof \lambda\overline\eta_1}$ is $l$-safe.
%\end{enumerate}
\end{lemma}
\begin{proof}
Immediate consequence of the definition.
\end{proof}

\begin{lemma}[Collapse simulation]
\label{lem:safecollapsesimulation}
Let $s$ be a sub-stack of a reachable configuration of $CPDA(G)$ and $l\geq 0$.
If $\ord s \geq 2$ and $top_2\,s$ is $l$-safe or if $\ord s = 1$ and $s$ is $l$-safe then for any lambda node $\lambda\overline\eta$ in $\orddec_l(s)$ we have:
$$collapse\,s_{\prefixof\lambda\overline\eta} = pop_{n-\ord \lambda\overline\eta +1}\,s_{\prefixof\lambda\overline\eta} \ . $$
\end{lemma}
\begin{proof}
The $collapse$ operation is defined as  $collapse\,s = pop_j^k\,s$ where $(j,k)\in\nat\times\nat$ is the link attached to $top_1\,s$.
Since $s$ is a sub-stack of a reachable configuration, we have $j = n-\ord \lambda\overline\eta +1$, and since
$top_2\,s$ is safe and $\lambda\overline\eta$ belongs to the order-decomposition, the height component is necessarily equal to $1$.
\end{proof}
Similarly, by Remark \ref{rem:linkorder_cpdaprime}, for configurations $s$ of the automaton $CPDA'(G)$ we have:
$$collapse\,s_{\prefixof\lambda\overline\eta} = 
\left\{
\begin{array}{ll}
pop_1\,s_{\prefixof\lambda\overline\eta} & \mbox{if $\lambda\overline\eta$ is prime,}\\
pop_{n-\ord \lambda\overline\eta +1}\,s_{\prefixof\lambda\overline\eta} & \mbox{otherwise.}
\end{array}
\right.
$$


\subsubsection*{Operations preserving stack safety}
\begin{lemma}
\label{lem:push1pop1_preserves_safety} Let $s$ be a higher-order
stack. Suppose that $s$ is $l$-safe, $l\geq0$. Then:
    \begin{enumerate}[(i)]
    \item $top_{\ord{s}}\,s$ is $l$-safe;
    \item if $top_1\,s$ is not a lambda node then $pop_1\,s$ is $l$-safe;
    \item for every non-lambda node $a$, $1\leq j\leq n$, $k\geq 1$, $push_1\,a^{(j,k)}\,s$ is $l$-safe;
    \item for every lambda node $a$, $push_1\,a^{(1,1)}\,s$ is $l$-safe if $\ord a < l$, and safe if $\ord a \geq l$.
\end{enumerate}
\end{lemma}
\begin{proof}
This is a direct consequence of Lemma \ref{lem:push1pop1_orderdecompo}.
For (vi), the cases $\ord a > l$ and $\ord a < l$ follow immediately from Lemma \ref{lem:push1pop1_orderdecompo}(i);
for $\ord a = l$ it follows from the fact that $\orddec_0 (push_1\,a^{(1,1)}\,s) = \orddec_l (s) \cdot a^1$.
\end{proof}

\begin{lemma}
\label{lem:incrk_qsafe}
Let $0\leq l < n$, $q\geq 0$ and $s$ be a stack of level $1\leq \ord{s} <n$.
If $s$ is $q$-safe then $s^{\langle n-l+1 \rangle}$ is $\max(l,q)$-safe.
\end{lemma}
\begin{proof}
Let $s$ be a safe stack with $1\leq \ord s <n$. We prove the result by induction on the size of $s$.
The base case is the trivial: $s$ is the empty stack.
Step case: Since $s$ is $q$-safe we have
$\orddec_q(s) = \langle \lambda \overline{\eta}_r^1
, \ldots, \lambda \overline{\eta}_1^1   \rangle$.
By (\ref{eqn_safe_prefix}), $\orddec_{\max(l,q)}(s)$ is a prefix of $\orddec_q(s)$.
Let $b$ be the index in $\orddec_q(s)$ of the last node of $\orddec_{\max(l,q)}(s)$:
thus $\lambda\overline\eta_b$ is the last lambda node in $top_2\, s$ with order $>\max(l,q)$.

The stack-operation $(\cdot)^{\langle n-l+1 \rangle}$ updates the pointers as follows:
the height component of each link is incremented if the order of the stack symbol is $l$ and is kept unchanged otherwise.
Hence we have:
\begin{equation*}
\orddec_q(s^{\langle n-l+1 \rangle}) = \langle
\lambda \overline{\eta}_r^1, \ldots,  \lambda \overline{\eta}_{b}^1, \lambda \overline{\eta}_{b-1}^{k}, \lambda \overline{\eta}_{b-2}^1 \ldots,
 \lambda \overline{\eta}_1^{1} \rangle
\end{equation*}
for some $1 \leq k\leq 2$. And therefore:
\begin{equation}
\orddec_{\max(l,q)}(s^{\langle n-l+1 \rangle}) = \langle \lambda \overline{\eta}_r^1
, \ldots, \lambda \overline{\eta}_b^1 \rangle\ . \label{eqn:trivialityofcollapse}
\end{equation}

Now consider an index $j$ such that $b\leq j \leq r$ and $n-\ord{\lambda\overline\eta_j} +1 \leq \ord s$.
Since the height component of $\lambda\overline\eta_j$'s link is not affected by the operation
$(\cdot)^{\langle n-l+1 \rangle}$, this operation commutes with $collapse$ and we have:
\begin{equation}
 collapse\, s^{\langle n-l+1 \rangle}_{\prefixof \lambda \overline{\eta}_{j}}
= (collapse\, s_{\prefixof \lambda \overline{\eta}_{j}})^{\langle n-l+1 \rangle} \ . \label{eqn:commutecollapse}
\end{equation}

By assumption $s$ is $q$-safe therefore $collapse\,s_{\prefixof \lambda \overline{\eta}_{j}}$ is $q$-safe
if $j=b=1$ and $\ord(\lambda\overline\eta_{j-1})$-safe if $j>b\geq1$.

Since $collapse\,s_{\prefixof \lambda\overline\eta_j}$ is strictly smaller than $s$, by the induction hypothesis we have that
$(collapse\,s_{\prefixof \lambda\overline\eta_j})^{\langle n-l+1\rangle}$ is $\max(q,l)$-safe
if $j=b=1$, and $\max(\ord(\lambda\overline\eta_{j-1}),l)$-safe if $j\geq b>1$.

For $j>b$, $\lambda\overline\eta_{j-1}$ occurs in $\orddec_l s$ therefore $\ord(\lambda\overline\eta_{j-1}) > l$,
similarly for $j=b$ we have $\ord(\lambda\overline\eta_{j-1}) \leq l$.
Hence $(collapse\,s_{\prefixof \lambda\overline\eta_j})^{\langle n-l+1\rangle}$ is
\begin{enumerate}[(i)]
\item $\max(q,l)$-safe for $j=b=1$,
\item $l$-safe for $j=b>1$, and therefore $\max(q,l)$-safe by Lemma \ref{lem:stacksafety_immediate results},
\item $\lambda\overline\eta_{j-1}$-safe for $j>b$.
\end{enumerate}
This shows that $(collapse\,s_{\prefixof \lambda\overline\eta_j})^{\langle n-l+1\rangle}$ is $\max(l,q)$-safe, and therefore by (\ref{eqn:commutecollapse})
so is $collapse\, s^{\langle n-l+1 \rangle}_{\prefixof \lambda \overline{\eta}_{j}}$.
\end{proof}


\begin{lemma}
\label{lem:cons_qsafety} Let $s$ be a higher-order stack of level $\geq 2$ and $l\geq0$.
 If
\begin{enumerate}[1.]
\item $pop_{\ord{s}}\,s$ is safe,
\item and $top_{\ord{s}}\,s$ is $l$-safe,
\end{enumerate}
then $s$ is $l$-safe.
\end{lemma}
\begin{proof}
Let $s = [s_1 \ldots s_r~s_{r+1}]$ for some $l\geq0$.
We proceed by induction on  $top_{\ord{s}}\,s=s_{r+1}$.
The base case $s_{r+1} = \bot_{\ord{s}-1}$ is trivial.
Suppose that $s_{r+1}$ is not the empty stack.

\begin{enumerate}[(i)]
\item Clearly $\orddec_l\, s = \orddec_l\, s_{r+1}$, hence since $s_{r+1}$ is $l$-safe the lambda nodes in $\orddec_l\, s$ have all a link of height $1$.

\item Let $\lambda \overline{\eta}$ be a lambda node in $\orddec_l(s) = \orddec_l(s_{r+1})$ such that $n-\ord{\lambda \overline{\eta}}+1 \leq \ord{s}$.
Since its link is of height 1 we have
$collapse~s_{\prefixof \lambda \overline{\eta}} = pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof \lambda \overline{\eta}}$.

If $n-\ord{\lambda \overline{\eta}}+1 = \ord{s}$ then
$pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof \lambda \overline{\eta}} = pop_{\ord{s}}~s_{\prefixof\lambda\overline\eta} = pop_{\ord{s}}~s$ which is $l$-safe by the first assumption
and Lemma \ref{lem:stacksafety_immediate results}.

Otherwise $n-\ord{\lambda \overline{\eta}}+1 < \ord{s}$ and we have:
\begin{align*}
 & collapse\,s_{\prefixof\lambda\overline\eta} \\
&  \qquad    = pop_{n-\ord{\lambda \overline{\eta}}+1}~s_{\prefixof\lambda\overline\eta}
              & \mbox{since $\lambda\overline\eta$'s link has height 1} \\
 & \qquad  = [ s_1 \ldots s_l\ (pop_{n-\ord{\lambda\overline\eta}+1}~ {s_{r+1}}_{\prefixof\lambda\overline\eta}) ]
           & \mbox{$n-\ord{\lambda \overline{\eta}}+1<\ord{s}$}  \\
&  \qquad  = [s_1 \ldots s_p\ (collapse\, {s_{r+1}}_{\prefixof\lambda\overline\eta}) ]
          & \mbox{since $\lambda\overline\eta$'s link has height 1.}
\end{align*}

% we haver to show that  $collapse\,s_{\prefixof \lambda \overline{\eta}}$ is $k$-safe where ...
By the second assumption, $s_{r+1}$ is $l$-safe therefore $collapse~{s_{r+1}}_{\prefixof\lambda\overline\eta}$
is $l$-safe if $\lambda\overline\eta$ is the last node in the $l$-order decomposition,
and $k$-safe where $k$ is the order of the following node in $\orddec_l(s_{r+1})$ otherwise.

Since $|collapse~{s_{r+1}}_{\prefixof\lambda\overline\eta}| < |s_{r+1}|$ we can use the induction hypothesis
to show that the same hold for $[s_1 \ldots s_p\ (collapse\, {s_{r+1}}_{\prefixof\lambda\overline\eta}) ]$. Therefore it is $l$-safe and so is
$collapse\,s_{\prefixof\lambda\overline\eta}$ by the previous equality.
\qedhere
\end{enumerate}
\end{proof}


\begin{lemma}
\label{lem:pushj_safe_implies_l-safe} Let $n>l\geq 1$ and $s$ be a safe higher-order stack such that $2 \leq n-l+1 \leq \ord{s} \leq n$. Then $push_{n-l+1}\ s$ is $l$-safe.
\end{lemma}
\begin{proof}
Let $s=[s_1 \ldots s_{c+1}]$ be a safe higher-order stack such that $2 \leq n-l+1 \leq \ord{s} \leq n$. Then by Lemma \ref{lem:push1pop1_preserves_safety}(i), $s_{c+1}$ is safe.

We show that $push_{n-l+1}~s$ is $l$-safe by finite induction on the order of $s$.
    \begin{compactitem}
      \item Base case: $\ord{s} = n-l+1 $. We have
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$.

    Since $s_{c+1}$ is safe,  by Lemma \ref{lem:incrk_qsafe} $s_{c+1}^{\langle n-l+1\rangle}$ is $l$-safe, and by Lemma
    \ref{lem:cons_qsafety},  $[ s_1 \ldots s_{c+1} s_{c+1}^{\langle n-l+1
    \rangle}]$ is $l$-safe.

      \item Suppose $\ord{s} > n-l+1$. Then
    $push_{n-l+1}~s = [ s_1 \ldots s_{c+1} push_{n-l+1}\,s_{c+1}]$.

    Since $s_{c+1}$ is safe, by the
    induction hypothesis $push_{n-l+1}~s_{c+1}$ is $l$-safe, and by Lemma \ref{lem:cons_qsafety} so is $[ s_1 \ldots s_{c+1} push_{n-l+1}\,s_{c+1}]$.
\qedhere
    \end{compactitem}
\end{proof}





\section{Simulation and proof of correctness}
\begin{proposition}
The $\rightarrow$-reachable configurations of CPDA(G) are safe.
\end{proposition}
\begin{proof}
If $n =\ord{c} =1$ then the result holds trivially since $CPDA(G)$ does not contain
any transition of the form $push_j$ for $j>1$ and therefore the links in a reachable configuration all have a height component equal to $1$.

Take $n\geq 2$. Note that $CPDA(G)$ has the same set of $\rightarrow$-reachable configurations
as $CPDA'(G)$, so for simplicity we prove the result for this alternative definition. We proceed by induction on the $\rightarrow$-step relation. The initial configuration is clearly safe.
Suppose that $c$ is a safe $\rightarrow$-reachable configuration and that
$c \rightarrow c'$. We do a case analysis on $top_1\,c$:
\begin{itemize}
\item (A): We have $c'=push_1^{E_0(u),1}\,c =push_1\,E_0(u)^{(1,1)}\,c$ where $E_0(u)$ denotes a lambda node. It is safe by Lemma \ref{lem:push1pop1_preserves_safety}(iv).

\item (S):
We have $c' = push_1^{a}\,c = push_1\,a^{(j,k)}\,c$ for some dummy lambda node $a$
and undetermined link $(j,k)$. It is safe by Lemma \ref{lem:push1pop1_preserves_safety}(iv) since $\ord a = 0$.

\item (L): We have $c' = push_1^{E_1(u)} = push_1 E_1(u)^{(j,k)}$ where $E_1(u)$ is not a lambda node
 and $j,k\geq1$ are undetermined. It is safe by Lemma \ref{lem:push1pop1_preserves_safety}(iii).

\item ($V_1$) \& ($V_0$): Suppose $u$ is labelled by a variable $x$ of order $l$.
Since $c$ is safe we have $\orddec(c) = \langle \lambda\overline\eta_r^1 , \ldots, \lambda\overline\eta_1^1
\rangle$, $r\geq 0$. Since the recursion-scheme $G$ is safe, by Lemma \ref{lem:binder_in_ordecompos}, $x$'s binder is precisely the last node of $\orddec_l(c)$. Let $b$ be its index in $\orddec(c)$, and $i\geq 1$ be the index of $x$ 
in $\overline\eta_b$.


\begin{compactitem}
\item  ($V_1$): $l\geq 1$.
We have $c'= push_1\,E_i(top_1)^{(n-l+1,1)}\, t$ where
$t$ is given by $(push_{n-l+1};pop_1^p;collapse)(c) = collapse ((push_{n-l+1}\,c)_{\prefixof \lambda
\overline{\eta}_{b}} )$.
By Lemma \ref{lem:pushj_safe_implies_l-safe} $push_{n-l+1}\, c$ is $l$-safe therefore, since $\lambda\overline\eta_b$ is the last node in $\orddec_l(c)$, by definition of $l$-safety we have that $t$ is $l$-safe. Finally the lambda node $E_i(top_1)$ pushed by the last operation has precisely order $l =\ord(x)$ therefore
\begin{align*}
\orddec_0 (c') &= \langle \lambda\overline\eta_r^1 , \ldots, \lambda\overline\eta_b^1, E_i(top_1(t))^1\rangle \ .
\end{align*}
Thus all the lambda nodes in $\orddec_0 (c')$ have a link of height $1$.

We now need to show that safety is preserved when collapsing at nodes of $\orddec_0 (c')$. Let $b\leq j \leq r$, we have $c'_{\prefixof \lambda\overline\eta_j} =
t_{\prefixof \lambda\overline\eta_j}$. For $j>b$, the l-safety of $t$ implies that $collaspse\, c'_{\prefixof \lambda\overline\eta_j}$ is $\ord{\lambda\overline\eta_{j-1}}$-safe as required. For $j=b$ it gives that $collaspse\, c'_{\prefixof \lambda\overline\eta_b}$ is $l$-safe as required since $l = \ord{E_i(top_1(t))}$.

Now it remains to show that $collapse(c'_{\prefixof{E_i(top_1(t))}}) = collapse\, c'$ is safe.
Since we have $i\geq 1$ the node $top_1(c') = E_i(top_1(t))$ is not a prime lambda node, thus by the counterpart of Lemma \ref{lem:safecollapsesimulation} for $CPDA(G')$ we can simulate the $collapse$ by a $pop$:
\begin{align*}
collapse\, c' &=  pop_{n-\ord{E_i(top_1(t))}+1}\,c'  \\
               &= pop_{n-l+1}\, c' \\
               &= (push_{n-l+1};pop_1^p;collapse;push_1^{E_i(top_1),n-l+1};pop_{n-l+1})\,c
\end{align*}
The operation $pop_1$ and $push_1$ only affects the top $1$-stack.
Furthermore, since $x$'s binder has order $>l$, its link has order $<n-l+1$ therefore
the collapse operation following the $pop_1^p$ only affects the
top $(n-l)$-stack. Consequently, the operation $pop_{n-l+1}$ effectively restores the configuration
to its value prior to performing the $push_{n-l+1}$ operation:
$$collapse\, c' = c \ .$$
Hence $c'$ is safe.

\item ($V_0$): $l=0$ (which implies that  $b=1$). The configuration $c'$ is given by
$push_1 E_i(top_1)\,collapse(c_{\prefixof \lambda \overline\eta_b})$.
Since $c$ is safe by definition so is $collapse(c_{\prefixof \lambda \overline\eta_b})$.
Since the pushed lambda node $E_i(top_1)$  has order $l=0$, by
Lemma \ref{lem:push1pop1_preserves_safety}(iv) $c'$ is safe.
\qedhere
\end{compactitem}
\end{itemize}
\end{proof}

\begin{definition}[Simulating PDA]
Let $G$ be a safe recursion scheme.
We define $PDA(G)$ as the higher-order PDA obtained from
$CPDA(G)$ by replacing 
every $collapse$ operation by $pop_{n-\ord{top_1(s)}+1}$.
\end{definition}
Equivalently this PDA can be obtained from $CPDA'(G)$ by replacing 
every $collapse$ operation by $pop_1$ if $top_1\, s$ is prime, and by $pop_{n-\ord{top_1(s)}+1}$ otherwise. (See Remark \ref{rem:linkorder_cpdaprime}.)
\begin{theorem}[Correctness of the simulation]
$PDA(G)$ and $CPDA(G)$ are equivalent.
\end{theorem}
\begin{proof}
In $CPDA(G)$, the collapse operation occurs only in the steps ($V_1$) and ($V_0$). For ($V_1$) it is of the form:
$$collapse(pop_1^p(push_{n-l+1}~c))$$
for some $\rightarrow$-reachable configuration $c$, where $top_1\,c$ is a variable $x$ of order $l$ and span $p$.
By the previous proposition, $c$ is safe and by Lemma \ref{lem:pushj_safe_implies_l-safe} $push_{n-l+1}\, c$ is $l$-safe. Since $x$ has span $p$, after the operation $pop_1^p$ the top stack symbol is precisely $x$'s binder, which by Lemma \ref{lem:binder_in_ordecompos}, belongs to $\orddec_l(c)$, therefore
by Lemma \ref{lem:safecollapsesimulation} the collapse can be soundly simulated by a $pop$ of order
$n-\ord(top_1(pop_1^p(push_{n-l+1}\,c))) +1$.

The case ($V_0$) is proved similarly.
\end{proof}

\bibliographystyle{abbrv}
\bibliography{../bib/dphil-all}

\end{document}
