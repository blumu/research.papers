\documentclass[times, 10pt,twocolumn]{article}
\usepackage{latex8}
\usepackage{times}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{pst-tree}
\usepackage[defblank]{paralist}
%\usepackage[compact]{titlesec} % saves even more space
\usepackage{picins}


\theoremstyle{plain}% default
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{corollary}{Corollary}
\newtheorem*{KL}{Klein's Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{example}{Example}[section]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

% highlight for definition names
\newcommand\defname[1]{{\bf\em #1}\index{#1}}

% reduction, substitution
\newcommand\betared{\rightarrow_\beta}
\newcommand\betasred{\rightarrow_{\beta_s}}
\newcommand\betaredtr{\twoheadrightarrow_\beta} % transitive closure of the beta reduction
\newcommand\subst[2]{\left[ #1/#2 \right]}
\newcommand\captsubst[2]{\{#1/#2 \}}

% computation tree, eta normal form, traversals
\newcommand{\elnf}[1]{\lceil #1\rceil} % eta long normal form

% lambda calculus
\newcommand{\encode}[1]{\overline{#1}} \newcommand\dps{\displaystyle}
\newcommand\rulef[2]{\frac{\dps #1}{\dps #2}}
\newcommand\rulefex[3][5pt]{\frac{\dps
    #2}{\stackrel{\rule{0pt}{#1}}{\dps #3}}}
\newcommand\ord[1]{{\sf
    ord}(#1)} \newcommand\typear{\rightarrow}
\newcommand{\rulename}[1]{\mathbf{(\sf #1)}}

% set theory
\newcommand{\makeset}[1]{\{\,{#1}\,\}}
\newcommand\inter{\cap}
\newcommand\union{\cup}
\newcommand\Union{\bigcup}
\newcommand\nat{\mathbb{N}}

% game semantics
\newcommand{\sem}[1]{{[\![ #1 ]\!]}}

% logic
\newcommand\imp{\Longrightarrow}
\newcommand\zand{\wedge}
\newcommand\entail{\vdash}

% pcf and ia
\newcommand\ialgol{\textsf{IA}}
\newcommand\iacom{\texttt{com}}
\newcommand\iaexp{\texttt{exp}}
\newcommand\iavar{\texttt{var}}
\newcommand\pcf{\textsf{PCF}}

% justified sequence of moves
\newcommand{\oview}[1]{\llcorner #1 \lrcorner}
\newcommand{\pview}[1]{\ulcorner #1 \urcorner}


% trees
\newcommand{\tree}[2][levelsep=3.5ex]{\pstree[levelsep=3.5ex,#1]{\TR{#2}}}
\newcommand{\arclabel}[1]{\mput*{\mbox{{\small $#1$}}}}

\pagestyle{empty}

\begin{document}

\title{The Safe Lambda Calculus}

\author{William~Blum~~~~~~~~~~~C.-H.~Luke~Ong\\
Oxford University Computing Laboratory\\
Wolfson Building, Parks Road, Oxford OX1 3QD, ENGLAND\\
\{william.blum,luke.ong\}@comlab.ox.ac.uk
}

\maketitle
\thispagestyle{empty}

\begin{abstract}
  Safety is a syntactic condition of higher-order grammars that constrains occurrences of variables in the production rules according to their type-theoretic order. We introduce the \emph{safe lambda calculus}, which is obtained by transposing  (and generalising) the safety condition to the setting of the  simply-typed lambda calculus. In this calculus, there is no  need to rename bound variables when performing substitution, as  variable capture is guaranteed not to happen. In the  same vein as Schwichtenberg's 1976 characterisation of the  simply-typed lambda calculus, we show that the numeric functions  representable in the safe lambda calculus are exactly the  multivariate polynomials; thus conditional is not definable.  Finally we give a game-semantic analysis of safety: We show that  safe terms are denoted by \emph{P-incrementally justified strategies}. Consequently pointers in the game semantics of safe  $\lambda$-terms are only necessary from order 4 onwards.
\end{abstract}





\Section{Introduction}

\SubSection{Background}

The \emph{safety condition} was introduced by Knapik, Niwi{\'n}ski and
Urzyczyn at FoSSaCS 2002 \cite{KNU02} in a seminal study of the
algorithmics of infinite trees generated by higher-order grammars. The
idea, however, goes back some twenty years to Damm \cite{Dam82} who
introduced an essentially equivalent syntactic
restriction (for generators of word languages) in the form of
\emph{derived types}.
A higher-order grammar (that is assumed to be \emph{homogeneously
  typed}) is said to be \emph{safe} if it obeys certain syntactic
conditions that constrain the occurrences of variables in the
production (or rewrite) rules according to their type-theoretic
order. Though the formal definition of safety is somewhat intricate,
the condition itself is manifestly important.


As we survey in the
following, higher-order \emph{safe} grammars capture fundamental
structures in computation, offer clear algorithmic advantages, and
lend themselves to a number of compelling characterisations:

\begin{itemize}[{-}]
\item \emph{Word languages}. Damm and Goerdt \cite{DG86} have shown
  that the word languages generated by order-$n$ \emph{safe} grammars
  form an infinite hierarchy as $n$ varies over the natural numbers.
  The hierarchy gives an attractive classification of the
  semi-decidable languages: Levels 0, 1 and 2 of the hierarchy are
  respectively the regular, context-free, and indexed languages (in
  the sense of Aho \cite{Aho68}), although little is known about
  higher orders.

  Remarkably, for generating word languages, order-$n$ \emph{safe}
  grammars are equivalent to order-$n$ pushdown automata \cite{DG86},
  which are in turn equivalent to order-$n$ indexed grammars
  \cite{Mas74,Mas76}.

\item \emph{Trees}. Knapik \emph{et al.} have shown that the Monadic
  Second Order (MSO) theories of trees generated by \emph{safe}
  (deterministic) grammars of every finite order are
  decidable\footnote{It has been recently been shown
    \cite{OngLics2006} that trees generated by \emph{unsafe}
    deterministic grammars (of every finite order) also have decidable
    MSO theories.}.

  They have also generalised the equi-expressivity result due to Damm
  and Goerdt \cite{DG86} to an equivalence result with respect to
  generating trees: A tree is generated by an order-$n$ \emph{safe}
  grammar if and only if it is generated by an order-$n$ pushdown
  automaton.

\item \emph{Graphs}. Caucal \cite{Cau02} has shown that the MSO
  theories of graphs generated by
  \emph{safe} grammars of every finite order are decidable. In a recent paper, however, Hague \emph{et al.} have
  shown that the MSO theories of graphs generated by order-$n$
  \emph{unsafe} grammars are undecidable, but deciding their modal
  mu-calculus theories is $n$-EXPTIME complete \cite{hmos-lics08}.
\end{itemize}

\SubSection{Overview}



We can now explain the sense in which the
safe lambda calculus is safe by establishing its salient property: No
variable capture can ever occur when substituting a safe term in
another. In other words, in the safe lambda calculus, it is
\emph{safe} to use capture-\emph{permitting} substitution when
performing $\beta$-reduction.





\Section{The safe lambda calculus}
\label{sec:safe}
A first version of the \emph{safe lambda
  calculus} has appeared in an unpublished technical report
\cite{safety-mirlong2004}. Here we propose a more general and cleaner
version where terms are no longer required to be homogeneously typed
(see Section~\ref{sec:safe} for a definition).



We assume a set $\Xi$ of higher-order constants.
We use sequents of the form $\Gamma \vdash M : A$ to represent
terms-in-context where $\Gamma$ is the context and $A$ is the type of
$M$. For simplicity
we write $(A_1, \cdots, A_n, B)$ to mean $A_1 \typear \cdots \typear
A_n \typear B$, where $B$ is not necessarily ground.
We  write $\ord{\Gamma}$ for the set $\{ \ord{y} : y
\in \Gamma \}$ and ``$c \sqsubseteq S$'' to mean that $c$ is a lower-bound of the set $S$.
\begin{definition}\rm
\begin{inparaenum}[(i)]
\item The \defname{safe lambda calculus} is a sub-system of the
  simply-typed lambda calculus defined by induction over the
  following rules:
$$ \rulename{var}~\rulef{}{x : A\vdash x : A} \quad
\rulename{const}~\rulef{}{\vdash f : A} \  f \in \Xi $$
$$\rulename{wk}~\rulef{\Gamma \vdash s : A}{\Delta \vdash s : A} \quad
\Gamma \subset \Delta$$
$$ \rulename{app}~\rulef{\Gamma \vdash s : (A_1,\ldots,A_n,B)~\Gamma \vdash t_1 : A_1  \ldots  \Gamma \vdash t_n : A_n} {\Gamma \vdash s t_1 \ldots t_n : B}$$
where $\ord{B} \sqsubseteq \ord{\Gamma}$
$$ \rulename{abs} \ \rulef{\Gamma, x_1 : A_1, \ldots, x_n : A_n
  \vdash s : B} {\Gamma \vdash \lambda x_1 \ldots x_n . s :  (A_1, \ldots ,A_n,B)}$$
where $\ord{A_1, \ldots ,A_n,B} \sqsubseteq
\ord{\Gamma}$
\end{inparaenum}
\end{definition}

 The formation rules of
the calculus are designed to maintain a simple invariant: Variables
that occur free in a safe $\lambda$-term have orders no smaller than
that of the term itself.

\begin{example}[Kierstead terms]
\label{ex:kierstead}
Consider the terms $M_1 = \lambda f . f (\lambda x . f (\lambda y . y
))$ and $M_2 = \lambda f . f (\lambda x . f (\lambda y .x ))$ where
$x,y:o$ and $f:((o,o),o)$. The term $M_2$ is not safe because in the
subterm $f (\lambda y . x)$, the free variable $x$ has order $0$ which
is smaller than $\ord{\lambda y . x} = 1$.  On the other hand, $M_1$
is safe.
\end{example}

\emph{In what sense is the safe lambda calculus safe?} A basic idea
in the lambda calculus is that when performing $\beta$-reduction, one
must use capture-\emph{avoiding} substitution, which is standardly
implemented by renaming bound variables afresh upon each substitution.
In the safe lambda calculus, however, variable capture can never
happen.
\begin{lemma}[No variable capture]\label{lem:nvc}
\label{lem:homog_nocapture} There is
no variable capture when performing capture-permitting
substitution of $N$ for $x$ in $M$
provided that $\Gamma, x:B \vdash M : A$ and $\Gamma \vdash  N : B$ are valid judgments of the safe lambda calculus.
\end{lemma}
 Substitution can therefore be
implemented simply by capture-\emph{permitting} replacement, without
any need for variable renaming. In the following, we write
$M\captsubst{N}{x}$ to denote the capture-\emph{permitting}
substitution of $N$ for
$x$ in $M$.

\begin{example}
  In order to contract the $\beta$-redex in the term
\[f:(o,o,o),x:o
  \vdash (\lambda \varphi^{(o,o)} x^o . \varphi \, x) (\underline{f \,
    x}) : (o,o)\] one should rename the bound variable $x$ with a fresh name to
  prevent the free occurrence of $x$ in the underlined term from
  capture during substitution. Consequently, by the previous lemma,
  the term is not safe. Indeed, it cannot be because $\ord{x} = 0 < 1
  = \ord{f x}$.
\end{example}

\begin{lemma}[Substitution preserves safety]
\label{lem:subst_preserves_safety}
If $\Gamma, x :B \vdash M : A$ and $\Gamma \vdash N : B$ then $\Gamma \vdash M[N/x] : A$.
\end{lemma}

Safety is not preserved by $\beta$-reduction in general: Suppose that $w,x,y,z : o$ and $f : (o,o,o)
\in \Sigma$ then the safe term $(\lambda x y . f x y) z w$
$\beta$-reduces to $(\underline{\lambda y . f z y}) w$ which is unsafe since the underlined order-1 subterm contains a free occurrence of the
ground-type $z$. However if we perform one more reduction we obtain the safe term $f z w$.

In general, by performing further
reductions, it is always possible to end up with
a safe term.
One can define a notion of ``safe redex'' and ``safe $\beta$-reduciton''
guaranteeing that safety is preserved
after reduction.

\SubSection{Numeric functions representable in the safe lambda calculus}

There is no need for new names when computing $\beta$-reductions of
safe $\lambda$-terms, because one can safely ``reuse'' variable names
in the input term. Safe lambda calculus is thus cheaper to compute in
this na\"ive sense. Intuitively one would expect the safety constraint
to lower the expressivity of the simply-typed lambda calculus. Our
next contribution is to give a precise measure of the expressivity
deficit of the safe lambda calculus. An old result of Schwichtenberg
\cite{citeulike:622637} says that the numeric functions representable
in the simply-typed lambda calculus are exactly the multivariate
polynomials \emph{extended with the conditional function}.  In the
same vein, we show that the numeric functions representable in the
safe lambda calculus are exactly the multivariate polynomials.

\begin{theorem}
\label{thm:polychar}
The functions representable by safe $\lambda$-expressions using the Church Numerals
encoding are exactly the multivariate
polynomials.
\end{theorem}

\Section{A game-semantic account of safety}
\label{sec:gamesemaccount}
Our last contribution is to give a game-semantic account of the safe
lambda calculus. Using a correspondence result relating the game semantics of a
$\lambda$-term $M$ to a set of \emph{traversals} \cite{OngLics2006}
over a certain abstract syntax tree of the $\eta$-long form of $M$
(called \emph{computation tree}), we show that safe terms are denoted
by \emph{P-incrementally justified strategies}. In such a strategy,
pointers emanating from the P-moves of a play are uniquely
reconstructible from the underlying sequence of moves and the pointers
associated to the O-moves therein: Specifically, a P-question always
points to the last pending O-question (in the P-view) of a greater
order. Consequently pointers in the game semantics of safe
$\lambda$-terms are only necessary from order 4 onwards. Finally we
prove that a $\eta$-long $\beta$-normal $\lambda$-term is \emph{safe}
if and only if its strategy denotation is (innocent and)
\emph{P-incrementally justified}.






The proof of Theorem~\ref{thm:safeincrejust} depends on a
Correspondence Theoremthat relates the strategy denotation of a $\lambda$-term $M$
to the set of \emph{traversals} over a certain abstract syntax tree of
the $\eta$-long form of $M$. In the parlance of game semantics,
traversals are just (concrete representations of) the
\emph{uncovering} (in the sense of Hyland and Ong
\cite{hylandong_pcf}) of plays in the strategy denotation.

We now consider the game-semantic model of the simply-typed lambda
calculus. The strategy denotation of a term is written $\sem{\Gamma \vdash M : T}$. We define the \defname{order} of a move $m$, written $\ord{m}$, to be the length of the path from $m$ to its furthest leaf in the arena minus 1.

\begin{definition}\rm
  A strategy $\sigma$ is said to be \defname{P-incrementally
    justified} if for any play $s \, q \in \sigma$ where $q$ is a
  P-question, $q$ points to the last unanswered O-question in $\pview{s}$ with
  order strictly greater than $\ord{q}$.
\end{definition}
Note that although the pointer is determined by the P-view, the choice of the move itself
can be based on the whole history of the play. Thus P-incremental justification does not imply innocence.

The definition suggests an algorithm that, given a play of a P-incrementally justified denotation, uniquely recovers the pointers from the underlying sequence of moves and from the pointers associated to the O-moves therein.
Hence:
\begin{lemma}
\label{lem:incrjustified_pointers_uniqu_recover} In P-incrementally justified strategies, pointers emanating from P-moves are superfluous.
\end{lemma}

\begin{example}
Copycat strategies, such as the identity strategy $id_A$ on game $A$ or the evaluation map $ev_{A,B}$ of type $(A \Rightarrow B) \times A \typear B$, are all P-incrementally justified.
\end{example}


The Correspondence Theorem permits us to show the following:
\begin{theorem}
\label{thm:safeincrejust}
\begin{enumerate}[(i)]
\item If $\Gamma \vdash M : T$ is safe then $\sem{\Gamma \vdash M : T}$ is P-incrementally justified.
\item If $\vdash M : T$ is a closed simply-typed term and $\sem{\vdash M : T}$ is P-incrementally justified then the $\eta$-long form of the $\beta$-normal form of $M$ is safe.
\end{enumerate}
\end{theorem}

Putting Theorem \ref{thm:safeincrejust}(i) and Lemma
\ref{lem:incrjustified_pointers_uniqu_recover} together gives:
\begin{proposition}
  \label{prop:safe_ptr_recoverable} In the game semantics of safe
  $\lambda$-terms, pointers emanating from P-moves are unnecessary: they are uniquely recoverable from the underlying sequences of
  moves and from O-moves' pointers.
\end{proposition}


In fact, as the last example highlights, pointers are entirely superfluous at
order $3$ for safe terms. This is because for
question moves in the first two levels of an arena,
the associated pointers are uniquely recoverable thanks to
the visibility condition. At the third level, the question moves are all P-moves therefore their associated pointers are uniquely recoverable by
P-incremental justification. This is not true anymore at order $4$:
Take the safe term $\psi:(((o^4,o^3),o^2),o^1) \vdash \psi (\lambda \varphi . \varphi a) : o^0$
for some constant $a:o$, where $\varphi:(o,o)$. Its strategy denotation contains plays whose underlying sequence of moves is $q_0 \, q_1 \, q_2 \, q_3 \, q_2 \, q_3 \, q_4$.
Since $q_4$ is an O-move, it is not constrained by
P-incremental justification and thus $q_4$ can point to any of the two occurrences of $q_3$.

\SubSection{Safe PCF and Safe Idealised Algol}

\pcf\ is the simply-typed lambda calculus augmented with basic
arithmetic operators, if-then-else branching and a family of recursion
combinator $Y_A : ((A,A),A)$ for any type $A$.  We define \emph{safe}
\pcf\ to be \pcf\ where the application and abstraction rules are
constrained in the same way as the safe lambda calculus.  This
language inherits the good properties of the safe lambda calculus: No
variable capture occurs when performing substitution and safety is
preserved by the reduction rules of the small-step semantics of
\pcf. Using a \pcf\ version of the Correspondence Theorem we can prove
the following:
\begin{theorem}
\label{thm:safepcfpincr}
Safe PCF terms have P-incrementally justified denotations.
\end{theorem}


The possibility of representing plays \emph{without some or all of
  their pointers} under the safety assumption suggests potential
applications in algorithmic game semantics. Ghica and McCusker
\cite{ghicamccusker00} were the first to observe that pointers are
unnecessary for representing plays in the game semantics of the
second-order finitary fragment of Idealized Algol\cite{Reynolds81} ($\ialgol_2$ for
short). Consequently observational equivalence for this fragment can
be reduced to the problem of equivalence of regular expressions.  At
order $3$, although pointers are necessary, deciding observational
equivalence of $\ialgol_3$ is EXPTIME-complete
\cite{DBLP:journals/apal/Ong04,DBLP:conf/fossacs/MurawskiW05}. Restricting
the problem to the safe fragment of $\ialgol_3$ may lead to a lower
complexity.


\Section{Further work and open problems}

The safe lambda calculus is still not well understood. Many basic
questions remain. What is a (categorical) model of the safe lambda
calculus? Does the calculus have interesting models?  What kind of
reasoning principles does the safe lambda calculus support, via the
Curry-Howard Isomorphism? Does the safe lambda calculus characterise a
complexity class, in the same way that the simply-typed lambda
calculus characterises the polytime-computable numeric functions
\cite{DBLP:conf/tlca/LeivantM93}?  Do incrementally-justified strategy
compose? Can we obtain a fully abstract model of safe PCF by suitably
constraining O-moves ({\it i.e.}~``O-incremental justification'')?


\bibliographystyle{latex8}
\bibliography{../bib/dphil-all}

\end{document}
